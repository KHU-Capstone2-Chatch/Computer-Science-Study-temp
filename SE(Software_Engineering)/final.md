Chapter 8 - Software Testing

Development testing
개발에서 테스팅이 무엇인가
Test-driven development
데브옵스라던지
세상에 민감한 소프트웨어를 짤때의 테스트
Release testing
실제로 사용자에게 소프트웨어를 내놓기 위한 테스트
User testing
사용자 입장에서 하는 테스트

3 Program testing
두가지 측면의 테스팅
테스팅의 목적 이유
1) 프로그램을 만든 궁극적인 이유
입력이 주어졌을때 출력이 되는지 확인

정상시 입력과 정상시에 예측되는 동작을 하는가
개발하는 플랫폼과 동작하는 플랫폼이 다를 수 있는 등
프로그램이 비 정상 동작을 할 수 있음
제대로 된 인풋에 대해서 어떤한 이유로 잘못된 동작을 할 수 있음
잘못된 입력이 들어왔을때 제대로 대체를 하지 못하고 잘못된 동작을 할 수 있음

2) 어떠한 상황에서 프로그램이 잘못 동작하는 것을 발견하고 그것에 대해서 수정,개선 대응

테스팅을 다양한 단계로 이루어짐
사용자에게 실제로 넘어가서 실제서비스를 겸하면서 테스트하는 마지막 단계전에는
인위적으로 만들어낸 데이터를 주게 된다
그 프로그램이 어딘가에 투입이 되는 것, 투입되기 전에 이미 돌아가는 것이 있다면
실제로 투입되어서 대체해야할 소프트웨어가 과거에 다룬 데이터를 현재에 사용할 수도 잇음

실제로 동작하면서 서비스를 하면서 사용자를 받으면서 하는 데이터는 맨 마지막 단계에서
실제 사용자 일부에게 열리는 기간에 쓰이게 되고

테스트를 위한 대부분의 데이터는 인위적으로 만들거나
대체할 이전 시스템이 사용하는 데이터를 활용

테스트를 수행함으로써 잘못된것에 대한 에러
비정상적인 동작에 대한 예외사항
프로그램이 입력이들어와서 기능적으로 확인할 부분이 아닌 넌 펑션널한 부분에 대해서도 확인행야함

테스트가 잘 되면 프로그램이 안정적이다
그렇지만 테스트하는 것은 테스트를 수행하는 잡 내용들이 무엇을 테스트하는지에 대한 기술적 관점에 따라서
평가가 다양하기 때문에
테스트가 다 통과하면 에러가 없다 라는 관점보다는
어떠한 식으로든 에러가 존재하고 에러를 찾는 그런 과정이다
테스트는 에러를 찾아가는 과정

테스트는 우리가 생각했던 기능이, 설계한 요구사항대로 제대로 동작을 했느냐 를 확인하는 것이 중요
결국 이것이 varification
이 소프트웨어가 사용자에게 전달 및 직접 사용자가 동작시키면서
사용자가 돈을 낼만한 소프트웨어인가

요구사항에서 추출한 specification 사항들이 제대로 구현이 되어있는가 > varification
사용자가 돈을 낼만큼 가치있는 소프트웨어인가 > validation

제대로 동작해야할 곳에서 제대로 동작하는가
오동작하는 것은 언제 왜 발생하는지 두가지 관점에서 찾고
각각의 대해서 문제가 있는 부분을 대응하고 개선하는 것이 큰 테스트의 목적
더 나아가서
사용자가 돈을 낼마한 가치있는 소프트웨어인가를 테스트

4 Program testing goals
두가지 관점
프로그램을 테스팅하는 목적
1) 우리가 생각한대로 제대로 동작을 하는가?
첫번째로 프로그래밍을 테스팅하는 목적
개발자와 고객에게 프로그램을 보여줌 > 원래 생각했었던 기능 그대로 동작한다는 것을

소프트웨어에 대해서 추상적인 한문장으로 표현했던 요구사항을
더 세부적인 표현으로 작성한 모든 요구사항  
그 모든 요구사항에 대해서 구현한 코드
그 각각의 코드에 대해서 제대로 돌아가는지 테스트
> 모든 세부적인 요구사항 마다 하나 이상의 테스트를 수행해야함

custom software
요구사항이 구체적인 고객이 존재하는 소프트웨어

generic software
구체적인 고객 없이 직접 요구사항을 정의하고 개발한 소프트웨어
소프트웨어 시스템 feature들에 대해서 모두 테스트
이 feature들이 결합이 되어있는 복잡한 케이스, 복합기능들 전부 테스트 해야함

이것들을 만족했을때, 소프트웨어가 요구사항을 만족한다라고 할 수 있다

주어진 입력에 따라 예측된 결과가 나오는지 확인하는 작업

2) 프로그램에 문제가 있는지 발견, 확인하는 작업
생각할 수 없는 것들을 일으키는, 생각하는 창조적 생각이 필요
소프트웨어가 제대로된 입력에 대해서 잘못된 결과를 내놓는 것, 
원하지 않는 상황 규격을 만족시키지 않는 상황
제대로 되지 않은 입력에 대해서 제대로 된 결과를 내놓는 것

defect testing 문제점 찾기
프로그램의 이상 동작
프로그램의 crash
원하지 않는 결과 등등등...
> 모든 비정상적인 경우들을 찾는 것

5 Validation and defect testing
1) 프로그램이 제대로 동작해야하는 상황에서 제대로 동작하는 지
이걸 위해서 제대로 된 입력과 제대로된 예상 결과가 나오는지 확인하기위한 테스트케이스를 만들고 실행
2) 오동작, 문제가 있는 것을 찾는다
입력된 값이 제대로 일때 항상 제대로 된 결과가 나오는지
입력된 값이 제대로 일때 간헐적으로 잘못된 결과가 나오는지
입력된 값이 잘못된 값일때 프로그램이 주는지
입력된 값이 잘못된 값일때 제대로 된 결과가 나오는지

6 Testing process goals
1) validation testing
소프트웨어가 개발될때 의도한대로, 요구사항대로
제대로된 입력에 대해서 예상되는 제대로 된 결과를 내는지 확인
2) defect testing
제대로된 입력에 맞춰 제대로된 결과를 내지 않는 모든 상황을 생각, 찾는 과정

7 An input-output model of program testing
이미지

8 Verification vs validation
- Verification: 
"Are we building the product right”.
The software should conform to its specification.
상품을 맞게 만들었는가
요구사항을 제대로 구현했는가?
대부분 개발자의 관점

- Validation:
"Are we building the right product”.
The software should do what the user really requires.
맞는 상품을 만들었는가
사용자가 정말 요구하는, 고객이 원하는  소프트웨어인가?
개발자를 포함한, 설계, 기획, 마케팅,디자이너 모든 사람들의 관점에서 만들어진 프로그램을
유저입장에 가져다 두고 유저입장에서 재 컨펌 받는 것

이프로그램이 뭘 해야할지 상세하게 들어가기전에 선언하는 단계
시스템 레벨에서 요구사항이 정해지는 단계
디테일한 요구사항이 정해지는 단계
에서 계속 고객과의 소통, 피드백, 
프로토타입을 통해 고객이 정말 원하는 서비스가 맞는지 
끊임없이 확인하는 과정이 필요하다

9 V & V confidence
만든 하나의 프러덕으로 고객을 만족시켜야함

목적에 맞는 시스템이라는 신뢰감를 주는것 목표로 한다

세가지에 따라 다를 수 있다
- 소프트웨어의 목적
기능, 신뢰성, 성능 수치
소프트웨어의 목적에 맞는 것들을 만족시키는 것

- 사용자의 눈높이, 기대감
사용자는 소프트웨어에 대한 눈높이가 낮다 
> 사용자는 첫번째 소프트웨어를 만날때 기대감이 별로 없다, 의심의 눈으로 바라볼 것임
사용자가 의심하지 않을 만큼 안정적임을 보여주어야 함
돈을 낼만한 가치가 있다는 것을 validate해야함
사용자의 눈높이가 무엇일지
처음에 소프트웨어에 대한 거부감, 기대가 무엇일지 고민해야함

- 마케팅 관점, 마케팅 환경
비슷한 장르, 분야의 소프트웨어를 만드는 회사는 매우 많음
다른 경쟁사보다 더 빨리 개발해야함
>개발,테스트할 시간이 줄어든다 
> 테스트할 시간이 매우 줄 확률이 높다
> defect testing을 할시간이 더 줄것임
why > 요구사항에 대해서 입력에 대한 결과갑이 제대로 나오는지 확이하는 validation 테스트가 아니라
창의적으로 아이디어를 짜내고, 상상을 짜내서 수많은 베타테스터를 통해
예상할 수 없는 입력과 수많은 컴퓨터에서 테스팅을 통해 문제를 발견해야하기 때문에
더 많은 시간이 든다
> 테스팅에서 먼저, 나중에, 긴급, 천천히 해야할 것들의 우선순위를 정할 수 밖에 없다

시장에 내놓아야하는 시점에서
반드시 테스트해야할 사항들
시기적으로 언젠가 테스트를 해야할 것들을 리스트업 해야할 것들
고객 관점에서 당연히 수용할 수 있을만한 수준 고려

10 Inspections and testing
프로그램을 실행해서 입력값을 실제주고 그것에 대한 결과를 뽑아내는 것
> dynamic verification
동적으로 프로그램을 실행하면서 입력을 주고 그것에 따른 결과를 추출하는 행위
프로그램을 테스트 데이터를 주고 요구사항에 정의한 동작이 제대로 이루어지는 지 본다

하지만, 요구사항을 제대로 준수하는지, 커스터머의 요구사항에 부합하는지를 확인하는 방법에는
static verifacation도 가능, software inspection(관찰)
소스코드를 사람이 눈으로 보는 실제로 분석하는 것
실제 프로그램을 실행하지 않기 때문에 정적이라고 함
사람이 실제로 코드를 봄으로써 구조가 제대로 잡혀있는지
머릿속으로 입력을 주어서 제대로 동작하는 지 머릿속으로 확인
코드 리뷰라고 함
누군가가 다른 사람이 만든 코드를 봄으로써 성능이 떨어짐, 예외사항의 부족등을 확인할 수 있다.

11 Inspections and testing
Inspection은 전과정에 들어가 있음
페어프로그래밍을 하는 경우도 있음 > 같은 프로그램을 둘이 같이 짬
한명이 짤때 한명을 코드 리뷰를 
같은 부서에서 만든 소프트웨어를 코드 리뷰하는 것은 흔함
ex) 특별히 어떤 부분에서 병목 현상이 발생하면 전 팀이 함께 코드 리뷰를 하기도 함

testing > 프로토타입, 실제 프로그램

12 Software inspections
소스코드를 보면서
예상되는 오동작, 프로그램에서 예상되는 오동작, 제대로 돌아가지 않을 것들을 찾아내는 부분
좋은점
프로그램이 개발중이더라도 퀄리티를 높이는 테스트를 하는 과정을 할 수 있다.
즉 전체적인 과정에서 모두다 할 수 있는 효과적인 테스트

13 Advantages of inspection
정적인 프로세스
코드를 읽어감으로써 프로그램을 현재잇는 상태 언제든지 확인할 수 있다.
ex) 내가 만든 프로그램이 다른 프로그램과 연결되어 동작을 하는 경우
실제로 연결이 되어있지 않더라두 코드만 보면서 코드리뷰가 가능하다

대규모 컴퓨터를 동원해서 몇일동안 하는 것이 아님
사람이 인위적으로 읽고 머릿속으로 분석하는 것이기 때문에 큰 비용이 들지 않는다
> 완성되지 않은 부분에 있어서 지속적으로 코드 리뷰를 해도 좋다

비동작적인 부분non functional
표준을 준수했는가, 
프로그램의 구조가 호환성(A운영체제에서 B운영체제에서 돌아가는지) 
portability(pc에서 돌아가는 것이 모바일, 워치에서 돌아가는지)
maintainability

14 Inspections and testing
Inspections and testing are complementary and not 
opposing verification techniques
> Inspections 과 testing은 상호보안적이다

프로그램을 실행하지 않고도 테스팅 하는 과정 
프로그램을 실제로 실행함으로서 테스팅을 하는 과정
병행해서 사용해야한다

두가지 기법 모두 v&v 프로세스로 활용됨

15 A model of the software testing process
데이터가 있고 그것을 실행하는 시나리오가 있음
Test cases : 설계할때 시나리오를 기준으로 한 것
ex) 어떤 데이터를 보내면 그것을 받아서 동작을 하고 누군가에게 보낸다

(이미지)
기반으로 입력에 대한 데이터
테스트 실행
예상했던 결과가 제대로 나오는지 레포트 작성

16
테스트는 여러번 진행됨
1) 개발 테스트
소프트웨어를 만든 사람이 테스트
만든자가 만든 프로그램에 대해서 테스트를 진행
개발자는 상상의 나래가 본인의 입력을 준것에 
예상된 결과를 준것에만 중심을 줄 수 있다.

각각의 팀이 개발한 프로그램은 잘 돌아가지만
합칠경우 에러가 나기도함 > >> 테스트만 전담으로 하는 팀이 있음

2) 릴리즈 테스팅
시험팀, 검증팀 >> 별도의 테스트만 전담으로 하는 팀이 있음
테스팅 팀에서 개발자들의 소프트웨어를 묶어서
소프트웨어를 개발자에서 사용자에게 주는 중간과정의 테스트
즉, 유저에게 전달하기 전단계의 소프트웨어 만들어서
유저의 목소리를 가져와서 우리 개발에서 요구사항을 정리한것이 제대로 구현되었는지
전체적으로 테스트

3) 유저 테스트
유저는 본인이 원하는 소프트웨어가 만들어졌는지 테스트
유저 또는 유저를 대신할 수 있는 사람들을 통해서
사용자 관점에서 유저 테스트를 진행

17 Development testing
개발 테스트

18
개발팀에서 개발 결과물을 테스트
1) unit testing 
소프트웨어의 최소단위, 함수또는 객체
가장 작은 단계인 함수나 객체가 제대로 만들어졌는지 확인
ex) 머신러닝 해당하는 부분, 데이터를 읽는 부분, 데이터를 읽는 부분 
2) component testing
클래스의 인터페이스들이 연결이되는 등
함수가 함수를 호출, 클래스가 클래스를 호출하는 등을 검사
즉 인터랙션을 검사
ex) 머신러닝에 해당하는 클래스 간의 연결, 데이터를 읽어들이는 클래스 간의 연결
3) system testing
모두 묶어서 전체 시스템의 테스팅
파이널 프로덕트 레벨에서 테스팅

19 Unit testing
individual components 개별적인 컴퍼넌트
대부분 입력이 들어갔을때 제대로 결과가 나오는지
비정상적인 상황에 대해서 프로그램이 어떻게 반응하는지 테스트함

unint?
- 개별 함수또는 객체의 메소드
- 각각의 클래스가 가진 데이터(attributes, methods)
- 클래스 하나, 클래스들이 묶인 큰 클래스 하나

20 Object class testing
객체지향 프로그래밍 >
클래스에 대한 테스트가 가장 중요하다

- 객체이 있을때 메소드들이 제대로 동작하는가 확인
- 클래스가 관리하는 state, attributes, data를 제대로 세팅하고 수정하는 것이 가능한가 확인
- 클래스가 가능하면 수많은 케이스들에 대해서 제대로 동작하는지 확인

객체지향기법
Inheritance 유전의 법칙
base class에 공통적으로 사용하는 것들을 모아두고
드라이브드 클래스에서 유니크한 베이스로부터 만들어진 자식들이 서로 독창적일때
한 자식의 독창적인것을 넣음

베이스 클래스가 무결하고, 에러가 없을 수 없음!
드라이브드 클래스를 누군가가 만들었을때
그 의사와 목적에 100프로 부합하지 않을경우
오히려 에러를 유발할 수도 있음 	

클래스를 테스트 할때 유전의 법칙을 쓰게 되면
이번개발 과정에서 만들어지지 않은 코드들을 가져왔기때문에
테스트가 더 복잡하고 어려울 수 있다
> (ppt) 상속은 클래스 테스트 디자인을 더 어렵게 한다

21 ex) Weather station testing
메소드 들이 제대로 원하는대로 동작하는지 확인하는 과정
22
내부에 스테이터스 데이터가 잘 유지되고 관리되는지 확인
테스트 케이스 < 동적으로 프로그램이 실행되면서 입력이 주어지고 출력을 추출하는 행위
> 이럴때 시나리오 별로 하는 것이 맞다
디자인할 때 시나리오 별로 했음
ex) 부팅될때 하는 시나리오에 따른 시나리오 시퀀스 차트
시퀀스 차트, 스테이트 모델을 활용
> 시나리오에 맞춰서 테스트 케이스를 만들고 적용

23 Automated testing
우리가 만든 테스트 프로그램을 알아서 실행하도록 코드를 작성한다

모두 자동화한다.
테스트 프로그램을 짜는 프레임워크 활용
테스트 프로그램 프레임 워크를 사용하면 일반적으로 도움이 될만한 테스트 결과를 리포팅해준다

테스트는 별도의 프로그램을 짜고
테스트를할 프로그램보다 양이 더 크고
다 짜기 보다 프레임워크를 활용
시나리오별로 원하는 테스트를 실행가능
테스트 종료시 테스트 결과 리포팅 가능

24 Automated test components
테스트를 할때 거치는 것
테스트 개발할 프레임워크가 제공하는
테스트 단계
setup part : 테스트를 하기 위해서 셋업하는 단계
call part : 테스트를 할 대상을 실제로 실행하는 단계
assertion part : 결과가 맞는지 틀린지 확인하는 단계

25 Choosing unit test cases
두가지 종류
- 정상적 입력이 나왔을때 정상적으로 동작하는가
- 잘못된 동작을 찾아내는 작업

잘못된 입력이 나왔을때도 프로그램이 멈추지 않고 죽지 않는다
다시 살아서 제대로된 입력이 들어오는 것을 대비할 수 있어야한다.
ex) 본인이 원하지 않는 형태의 입력이 있을때 프로그램이 죽지않고 원하는 입력 형태를 알려주는

26 Testing strategies
테스팅 경험

가장 흔한것
1) 어떤 입력을 줄것인가?
입력을 어떤식으로 줄것인가?

ex) 정수를 입력받을 경우 > 모든 정수를 테스트할 수 없기 때문에
> 줄 정수의 범위를 주어야 한다.
입력값을 줄것에 대한 파티션을 주어서 샘플들을 테스트

2) 
대부분의 회사 개발자는 경험이 있다
회사의 경우 시간이 지남에 따라 나타나는 에러나 나타나는 문제점의 유형들이
대부분 많이 나타나는 문제점들은 정형화 된다.
테스트할때 정형화 되어서 나타나는 문제점들은
가이드라인 베이스로 해서 체크한다.

27 Partition testing
모든 값에 대해서 모두다 테스트를 할수 없기 때문에
특정적으로 주어지는 값들로 테스트 수행
특정적 주어지는 값은 전체를 대표하는 샘플
테스트를 수행할 때 모든 케이스에 대해서 하기 어렵기 때문에
군으로 나누어서 수행

파티션을 잘못하면 오류를 놓칠수도 있음 주의

28 Equivalence partitioning
군으로 묶음
군들에 대해서 일부 샘플들이 테스트 됨
그렇지 않은 부분에서 발생하는 부분은 에러 스페이스

무한정 테스트를 할수 없으므로 중요하다

29 Equivalence partitions
입력 파라미터를 세타입으로 분류한 예시
군이 다른 입력들을 테스트 해야함
> 군이 바뀌는 지점에있는 값을 테스트하면 좋다

30 Equivalence partitions
- 에러를 유발하는 인풋을 준다
- 인풋 버퍼가 오버플로우되는 경우
- 입력값을 반복적으로 넣어 값을 업데이트에 문제가 있나 확인
- 계산 결과가 매우 크거나 작게 만든다
누구나 격는 에러들
이미 경험한 내용에 대한 가이드 라인을 따르면 좋을 것임

31 Component testing
수많은 오브젝트들이 서로 호출하고 데이터를 가져가는 것

메소드들을 포함해서 하나의 클래스 오브젝트가 바깥과 통신하기 위해서는
대부분 인터페이스가 정해져 있다.

메소드를 직접 호출하는 것이 아니고 파일을 이용할 수도 있고, 컴퓨터 메모리도 사용 가능
다양한 기법으로 오브젝트트 들 간의 정보 주고받기 가능

유닛테스트는 충분히 이루어져서 
함수와 클래스에 대한 기능을 테스트를 마쳤다고 생각함
함수,클래스 그들간의 인터페이스 관점에서 테스팅 진행

32
클래스 오브젝트 클래스 하나에 대해서 테스트할 때 메소드같은것은
상당량 테스트가 되었다
객체와 객체 혹은 같은 컴퓨터에 있지 않은 객체들 간의 인터페이스를 하는 경우
다양한 방법이 동원
다양한 방법을 활용하는 클래스가 제대로 동작하고 제대로 호출되는지 확인	

인터페이스 타입
- 파라미터 인터페이스
메소드를 호출하는 것은 파라미터를 전달하는 파라미터 인터페이스 방식
클래스를 구성하는 멤버메소드를 호출할때 입력 파라미터를 준다.
> 
입력 파라미터로 제대로된 값을 줄때 제대로된 결과값이 나오는지 확인
입력 파라미터로 제대로 된 값을 주지 않았을때 어떤 상황이 벌어지는지 화인

- 쉐어드 메모리 인터페이스
임베디드 프로그래밍에서 많이 사용하는 방식
기능을 요구하는 A와 기능의 요구를 받는 B가 컴퓨터 메모리 램을 사용해서 
ex)요청한 자가 입력 파라미터를 램에 쓰고 요청받은 자는 램에서 값을 읽는다
결과를 돌려줄때도 마찬가지
동일한 컴퓨터 메모리를 호출하는 자 A와 호출받는자 B가 공유한다.

- 프로시듀어 인터페이스
여러 절차 등을 한꺼번에 묶어서 수행하는 경우 > 밖에 보일수도 안보일수도 있는데  대부분 보여주지 않는 것
이러한 절차들이 제대로 지켜져 있는지를 호출, 테스트

- 메시지 패싱 인터페이스
컴퓨터들이 통신을 통해서 따로 떨어져있는 경우가 있음
이런경우 메시지를 통신을 통해 전달
e) A컴퓨터 위에있는 A프로그램이 B컴퓨터 위에 있는 B프로그램에게 통신선로를 통해 메세지를 보내면
B컴퓨터의B프로그램에서 작업을 한다	

일반적으로는 메소드를 호출하는 파라미터 인터페이스

성능을 올리기 위하거나, 통신으로 수많은 컴퓨터가 동원, 복잡한 일을 간소화 하는 등은
다른 인터페이스들도 사용

컴포넌트 테스팅 > 이러한 인터페이스를 확인하는 작업


33
외부에서 test case를 보내서 컴포넌트 들이 제대로 인터페이스가 되는지 확인

34 Interface errors
- Interface misuse
인터페이스를 잘못쓴것
줘야할 파라미터 타입을 맞추지 않았거나, 파라미터의 순서가 잘못된 경우

- Interface misunderstanding
인터페이스를 잘못이해 > 
요구사항을 읽지 않고 전달, 작업을 제대로 이해하지 않고 호출, 돌려주는 결과가 먼지 제대로 이해하지 않고 사용 
ex) 만약 바이너리 서치 인풋 배열이 정력되어있어야함
작업에 대한 설명을 읽지 않고 정렬되지 않는 배열을 인풋
형태는 맞지만, 의미가 잘못됨, 돌려주는 값이 무엇인지 잘 몰라서 에러 발생 가능
 
- Timing errors
shared, massege 방법에서 자주 발생
A가 B에게 기능을 요청하는데 
컴퓨터 메모리에 롸이팅을 한 다음 
그 컴푸터 메모리에 쓰여져있는 것을 보고 B가 작업

B가 A로부터 기능 호출을 받았을때 미쳐 컴퓨터 메모리에서 데어터를 못가져오거나

A와 B가 같은 값을 가지고 움직여야하는데 시간이 밀릴 수 있음 
(둘이 동일 시가으로 움직여야하는데 두 컴퓨터의 시간이 어긋날 수 있음)

AB가 정보를 ㅇ주고받을때 동일한 시간때에 동일한 정보를 읽어야하는 타이밍 이슈가 있다면
반드시 지켜줘야하느 부분이 있고

임베디드, 통신, 하드웨어 프로그램에서 많이 발견되는 이슈 

35 Interface testing guidelines
가이드라인이 있다

-데이터를 줄때 값을 전달한다면, 전달하는 값의 최대 최소값 중간값을 줄 필요가 있다
군이 나누어진다면 군마다 최대 최소를 줘보기
- 주솟값을 전달하는 경우 null 포인터라는 의미 없는 주솟값을 주엇을 때 프로그램이 잘 대처하는지
- 제대로 되지 않은 입력을 주었을때 프로그램이 죽는지 사는지
- stress testing 부하를 많이 주는 것 > 특히 통신 프로그램에서 
초당 몇개의 메세지까지 처리할 수 있는지 확인
처리할 수 없는 부하가 들어올 경우 프로그램이 죽지 않고, 
일부 통신을 버리는 등 프로그램이 죽지 않게 하는 것이 중요
- shared memory 시스템에서 쓰는 자가 메모리에 쓰고 메모리에 쓰는게 완료된 후
읽는자가 완료 된 후 읽게 함

35 System testing

36
내가 만든 함수, 클래스를 unit test
팀이 만든 함수들과 클래스를 합친 component test
모든 컴포넌트들을 합쳐서 테스트

컴포넌트들을 하나의 시스템으로 넣는 과정
system intergrated
system build라고 함

컴포넌트 들 간의 인터랙션이 제대로 이루어지는가 테스트

가장큰 목적
시스템에서 해야할 일을 테스트한다

37 System and component testing
컴포넌트들을 연결

시스템 테스팅의 경우 대부분 전담팀이 함

직접개발하지 않고 사와서 쓰는 부분이 있을 수 있음(off the shelf)
사온것을이 우리가 개발한것과 통합하는 과정이 필요

> 독자적으로 개발한 컴포넌트들의 통합과 더불어
사온 프로그램까지 합치는 과정

규모를 갖춘 회사는 대부분다 개발디자인과 독립된 팀이 작업을 진행

38 Use-case testing
유즈케이스, 시나리오를 기반으로 테스팅하는 접근 방식이 일반적으로 사용

시스템들간의 순차적으로 어떤 작업들을 해야하는 그에 따른 절차 요구되는 값들에 대해 이해하고 테스팅

시퀀스 다이어그램에 맞춰서 테스트 프로그램을 짜서
자동화된 소프트웨어에 의해서 데이터를 입력하고 값을 받고 테스트 리포팅을 하는 작업을 진행

39 Collect weather data sequence chart
(이미지)
잘못된 데이터가 왔을때의 대비에 대한 것들도 모두 그려야함
모든 비정상적인 동작들에 대한 것들도 모두 그려야함

모든 컴포넌트들을 통합하는 것
사용자와 시스템 사이의 인터랙션

40 Test cases derived from sequence diagram
-요청을 보내는 사람은 그것에 대한 응답을 받는다
받은 응답이 맞는 결과인지 테스트 해야한다

엉뚱한 요구에 대한 대처에 대해서 테스트를 위해서
엉뚱한 요청에 대한 예상 데이터와
엉뚱한 요청에 대한 예상 결과값을 가지고 있어야함

모든 것들을 통합하고,
사용자의 요구를 받아 제대로된 결과가 나오는지를 확인하는 과정

올바른 요청과 제대로 된 결과
잘못된 요청과 그것에 따른 결과

41 Testing policies
테스팅 기간이 길수록 에러가 많이 처리되지만
마케팅팀 입장에서 반대

자원은 항상 부족
> 소프트웨어의 어디까지 테스트를 할것인가 물리적으로 정해야함

ex
컴퓨터를 사용하고 있는 유저 입장에서 보는 메뉴들이 있다면
그 메뉴에 대한 모든 기능들을 테스트해야함

같은 메뉴가 눌렸을때 연결되어서 동작되는 것은 모두 연결해서 테스팅 해야함

입력값이 사용자로부터 요구되었을때 제대로되었을때와 
제대로 되지 않았을때 가정하고 테스팅해야함


42 Test-driven development
방법론, 기법

: 테스트가 주도하는 개발
요구사항을 받아서 설계하고 개발하고 > 테스트 단계

애자일 개발과 운영인 데브옵스등의 서비스 중심의 개발기법에서 많이 사용한다
플랜베이스나 워터폴에서도 사용하기는 함

개발코드를 요구사항을 보고 구현하기 전
내가 구현할 코드에 대한 테스트 코드를 먼저 짜고
프로그램을 구현 후 테스트코드로 바로 테스팅 진행

43 Test-driven development
테스팅과 코딩 과정이 밀결합되어있음

테스트 프로그램 > 기능 프로그램
테스트 프로그램 강화 > 기능 프로그램 확장
반복

테스트할 코드를 먼저짠다

ex)
클래스에 메소드가 5개라면
클래스 메소드 1개를만들기 전에 
1개에 대한 테스트 코드를 먼저 짜고
> 메소드 개발
> 다음 메소드에 대한 테스트 코드 개발
> 메소드 개발

테스트 코드를 얼마나 작게 하고 주기를 얼마나 반복할지는 정하기 나름 

테스트 코드와 개발 코드가 인크리멘탈하게 자라남

애자일과 같이 개발의 페이즈가 인크리멘탈 하고 짧은 주기인 프로그램을 개발할때 주로 사용
플랜 베이스드 프로그램의 경우에도 적용 가능하다

44 Test-driven development
TDD의 특징
ex) 
멤버 메소드가 10개인 클래스를 구현

(이미지)
새로운 기능에 대해서 확인 >
테스트코드를 짜고 > 바로 테스트 진행 > fail (아직 테스트할 코드 조차 짜지 않은 상태)
> fail한 기능을 개발
> 테스트 진행 > pass > 처음으로 돌아감

45 TDD process activities
인크리멘탈하게 소프트웨어를 개발하는 것이 근본적인 목적
얼마나 인크리멘탈하게 할것인가 본인이 정하고
애자일 경우 하나의 스프린트 단위로도 할 수 있음

소프트웨어의 작은 부분을 개발하고 테스트하는 과정을 반복하면서
소프트웨어가 안정화 되고 기능적으로도 문제가 없는 방향으로 가게 한다

작은 부분에 대해서는 짜야할것 확인 > 미리 테스트코드를 짜고 > 테스팅 > 실제 코드 작성
*모든 앞 단계가 정상적으로 통과했을때 다음으로 넘어감

46 Benefits of test-driven development
왜 하냐?
- Code coverage
함수 하나 단위로 반복작업을 함
모든 요구사항에 대해서 최소한 하나이상의 테스트가 이루어져야하기 때문에 
자동적으로 코드 커버리지를 만족
- Regression testing 
두번째 메소드를 작성하면서 잘 짰다고 생각한 첫번째 메소드 에러가 발생 할 수 있는데
그것을 계속 확인하면서 코드를 확장해 나감
- Simplified debugging 
디버깅이 쉽다
앞단의 경우 에러가 날 확률이 적다는 것을 알기 때문에
어디서 에러가 났는지 효율적으로 찾아서 해결 가능
- System documentation
애자일에서 문서를 만들고 싶지 않음
테스트 코드가 정형화된 형태를 띔 > 의미가 매우 명확함
테스트 프로그램 자체가 일종의 문서로 쓰일 수 있다

47 Regression testing
회귀 테스트
이전에 제대로 동작을 한것이
새로운 기능을 넣으니 이전에 개발한것에서 뜻하지 않는 에러가 발생하는 상황

새롭게 조금씩 조금씩 진행하다보면 문제가 어디서 발생했는지에 대해서 집중할 수 있는 부분이 줄어든다

테스트 코드는 원래 있는것에 추가가 되는 것이기 때문에
새로운 코드를 넣었을 때 기존에 있는 코드에서 오류가 발생한다면
그 코드가 무엇을 테스트했는지 확인해서 
디버그할 부분이 명확해져서 더 적은 시간을 들일 수 있음

++
테스트 코드를 통과할 수 있을 만큼의 코드를 짜라, 너무 많이 쓸데없이 코드를 짜지 마라
테스트 코드는 내가 필요한 것 방지한것에 대해서 썼다면
실제 코드는 테스트 코드를 통과할 수 있는 정도만 짜라

48 Release testing

49 Release testing
소프트웨어가 개발팀을 완전히 떠남
개발 관련 테스트는 끝남

사용자 입장에서 테스트

black-box testing, 시스템 내부를 모른다는 가정하에 이루어지는 테스트
시스템 내부적인 상황은 모르고
사용하는 사용자의 관점에서 내가 원하는 것을 요청하고 원하는 결과가 오는지를 테스트

시스템 요구사항 명세서가 제대로 갖추어졌는지를 테스트한다

50 Release testing and system testing
시스템 테스팅의 연장선상이라고 할 수있다.

개발팀에서 벗어나서 전용팀이 꾸려짐
객관적인 시각에서 프러덕이 고객에게 전달될만한 물건인지 확인

외부에서 고객입장에서 시스템 레벨의 요구사항, 즉 고객이 제시한 요구사항이 만족되는 지 확인

51 Requirements based testing
시스템 요구사항에서 도출되었던 사항에 대해서 테스트함

ex) 멘탈케어 시스템
알러지가 있는 약 처방시 경고 메세지 > 무시할경우 이유 적게 하기

52 Requirements tests
아마도 릴리즈 테스트 팀이 키보드와 마우스를 가지고 유저인터페이스를 사용하면서 테스팅

ex)
알러지가 없는 환자는 > 경고 메세지 없음
알러지 있는 환자 > 경고 메세지 띄움
..등등

53 A usage scenario for the Mentcare system
시나리오 베이스로 테스트할 케이스를 만든다
ex)

54 Features tested by scenario
기술적인 관점도 진행을하긴함
ex)
로그인이 잘 되는지
정보 업로드 다운로드가 잘 되는지 
정보 암호화가 잘 되는지 등

55 Performance testing
사용자가 사용한 컴퓨터 운영체제를 거의 동일하게 만들고
프로그램에 요구된 성능을 테스트

시스템은 사용자가 증가하면 제한된 cpu 네트워크가 급격하게 증가하지 않도록 하고
처리를 못하는 상황을 대비
부하 되는 상황에 시스템이 죽지 않게 해야함

stress testing
보장한 정도의 부하까지 가능한지 테스트 

56 User testing
고객이 만족하는지 확인하는 테스트
57 User testing
사용자가 시스템을 실제로 사용하고
개선점, 잘못된 점들
돈을 줄지 말지 결정하는 과정

어떤 프로젝트 프로세스에서도 반드시 이루어지는 경우가 많다

처음에 시작할때 프로그램을 요청한 사람을 만족시키기 위해서 노력해야함

58 Types of user testing
- Alpha testing
유저 테스팅의 알파 단계
상용 출시를 앞둠
시스템 레벨에서 테스팅을 완료
릴리즈 테스팅까지 완료

외부의 반응을 보기 위해서
알파테스트 진행
> closed  선별적인 사용자들에게 의견을 묻는 방식
이 프로그램을 의뢰한 아주 소수의 그룹들이 테스트 진행
어느정도 어떤 프로그램인지 알고 있는 사람들
가능한 개발 구획 내에서 진행

- Beta testing
시스템이 어떻게 만들어졌는지 모르는 사람
기존의 시스템에 더 익숙한 사람들에게 테스트

문제를 제시 >수정
개선점 > 업그레이드

- acceptance testing
고객이 돈을 줄지 말지 결정하는 테스트
요구한자가 요구사항에 맞춰서 잘 개발이 되었다고 인정하는 과정

>
공실 릴리즈 출시 후
버그 리포트에 맞춰서 유지보수 단계로 넘어감

59 The acceptance testing process
(이미지)

요건 만족 기준 결정(요구사항 계약 참고)
> 계획
> 실제 테스트 코드 또는 환경 구축
> 테스트
> 협상
> 허락 or 거절 선택

> 허락 > 릴리즈, 출시

60 Stages in the acceptance testing process
위 내용 반복

61 Agile methods and acceptance testing

애자일의 경우
외부 사용자가 쓰는것을 개발하지만
소프트웨어를 만들고 요구사항을 적는 것은 내부에서 작성

acceptance testing
> 애매하다
외부에 낼만한 요구사항을 만족하는지 확인하는 과정은 필요할것이다.

개발 팀도 일부 유저/고객이라고 할 수 있다
또는 유저를 대신할 수 있는 사람이 내부에 따로 있을 수 있다

오퍼레이션팀이 acceptance 하는 사람이 될 수도 있음

릴리즈 테스트와 acceptance testing가 합쳐졌다고 볼수도 있음

없다고도 볼 수 있다

실제로 대기업에서 서비스 알파 베타테스트를 실제 사용자들을 대상으로 진행하는 경우도 있기때문에
어떻게 보면 acceptance testing을 하고 있다고 볼수도 있음

> 결국 중요한 것은
의미적으로 고객, 사용자가 만족하는지 테스트 하는 것은 반드시 필요하다

-----------------
문제가 없음을 증명하는 것 x
문제가 있는 것을 찾아가는 과정


Chapter 9 – Software Evolution
기존의 탑다운 waterfall 방법을 기저에 깔고 이야기를 진행
물론 애자일 데브옵스 와 같은 최신 인터넷 기법에 서도 사용 가능

2
² Evolution processes
 소프트웨어가 출시된 뒤 끊임없이 개선되고 발전
² Legacy systems
누군가 만든 오래된 소프트웨어가 돌아가는 환경에 대한 이해
² Software maintenance
어떤 작업들이 출시된 이후에 이뤄지는지

3 Software change
고객의 소프트웨어가 완전히 전달되는 과정

소프트웨어가 변화할 수밖에 이유
- 놓쳤던 새로운 요구가 들어옴
- 소프트웨어가 출시된 이후에 들어온 새로운 피쳐
- 비즈니스 환경 변화
- 소프트웨어를 설계할때와 달라진 요구사항 > 새로운 기능, 피쳐, 성능, 넌펑셔널 피쳐 
- 원초적 > 테스트과정에서 걸러내지 못한 수많은 에러
- 새로운 컴퓨터나 기기 즉 하드웨어에 환경의 변화에 맞추어 소프트웨어의 변화
ex) vr 기기 등
- 시스템의 성능이나 신뢰도 등등에 대한 변화
ex) 
원자력 발전소 > 지구 온난화에 대한 대처
2030년전 만들어진 건물 > 변화한 지진에 대한 대처

소프트웨어가 한번 만들어지면
이후에 이런 변화를 반영하는 것은 필연적
어떻게 할것인가에 주안점이 있다

4 Importance of evolution
소프트웨어를 도구로 하는 회사가 늘어남
소프트웨어에 많은 투자를 함

한번 만들어진 소프트웨어는
비즈니스의 시작과 끝을 담당
비즈니스에 투입되면 비즈니스가 변경이 되면 소프트웨어에 반영해야함

한번 출시되고 나면
소프트웨어가 비즈니스에 투입되었을때 문제가 발생햇다면?
설계문서를 제대로 고쳐야하지만
설계문서를 업데이트하고 그것을 반영할 시간이 부족
> 바로 소프트웨어를 고치는 상황 발생(설계문서 반영x)
즉, 설계문서가 소프트웨어가 출시되고 나면 무용지물이 되는 경우가 많음
> 따라서, 소프트웨어 안에 당장 회사 필요로 하는 비즈니스 로직이 구현되어있다
> 현재 이 소프트웨어를 다른 소프트웨어로 대체한다면?
다른 소프트웨어를 짤때 참고할 설계문서에 
소프트웨어 출시 이후 즉석으로 코드를 고친 것들에 대한 내용이 없음!

>> 새로운 소프트웨어 대체하는 것 보다는 기존의 소프트웨어가 발전되는 것을 원함
새로운 소프트웨어로 바꾸는 것 자체가 큰 부담을 준다	

>> 유지 보수하는 것의 필연성에 대한 이야기였음

5 A spiral model of development and evolution
(이미지)
릴리즈1 > 릴리즈2 > 릴리즈3

우선순위가 높은 것을 릴리즈 1에 반영

릴리즈1을 운영하면서 발생한 다양한 변화에 대해서
릴리즈2에 반영

6 Evolution and servicing
(이미지)
소프트웨어 생애 주기

개발 > 진화 > 서비스 > 은퇴

진화 > 서비스
단계에서 소프트웨어 새로운 기능 x
완전히 새로운 다음 버전을 준비
why?
서비스를 버림
하드웨어가 지탱할 수 없는 상황
등등 다양한 이유가 있을 수 있다

 7 Evolution and servicing
- Evolution
새로운 기능이 들어갈 수 있음
운영하면서 사용가능
버그 패치
- Servicing
더이상 새로운 기능 추가 x
사용자들이 사용하면 비즈니스 적으로 사용
운영을 위해서 필요한 경우만 변화 가능(ex 버그, 소프트웨어 환경 변화)
- Phase-out
소프트웨어 운영 중지, 단종
새로운 시스템으로 변경

8 Evolution processes
9 Evolution processes
어떤 프로세스
- 소프트웨어가 어떤 형태로 되어있는지?
ex)
임베디드 프로그램인지, 웹서비스인지
우리가 만들어서 우리가 쓰는건지, 우리가 만들어서 납품을 하는건지? 등등
- 개발 프로세스는?
애자일 vs 워터폴
- 누가 이런 소프트웨어를 짜고 그 사람의 역량,경험은?
사람 자체의 경쟁력, 사람들간의 교류 등 도 강조 되기 시작함

소프트웨어에 변화가 필요하다고 제안 proposal
- 얼마만큼의 비용이 드는가(시간, 비용, 인력)
ex) 소프트웨어 안에 컴퍼넌트들을 수정할 때 어느 클래스 컴퍼넌트 함수들이 수정되어야 할지
그것을 수정할 때 영향을 받는 것들 분석이 필요

- 어떤 과정을 거쳐서 변화를 찾아낼지
- 변화를 어떻게 반영함으로써 지속가능한 소프트웨어가 존재할 수 있도록 고민

10 Change identification and evolution processes
(이미지)
새로운 시스템 
> 변화 도출
> 변화 제안
> 소프트웨어 진화 프로세스

11 The software evolution process

개발자 입장에서

변화 요청
> impact analysis : 시스템에 변화가 반영되었을때 어떤 영향이 있을지 분석
(수정해야할 컴포넌트 자체, 그 컴포넌트와 연결된 또다른 컴포넌트들 분석
- 얼마나 많은 시간, 인력이 필요할 지 알 수 있음)
> release planning
(변화 인자 : falut repair - 테스트 과정에서 거르지 못한것, 보안이 강화되었을때, 보안적 구멍이 났을때 , 
platform adaptation - 운영체제가 바뀜으로써 영향을 받음, 믿고 사용하는 플랫폼의 변화, 
system enhancement - 시장,환경, 법규 규정 등의 non-functional 요구사항의 변화)
> change implementation > system release(새로운 시스템 출시) > 다시 반복
			      > release planning(수정을 함으로써 새로운 수정이 생길 수 있음)
12 Change implementation
(이미지)
플랜베이스드, 워터폴 방법을 사용한다면
다음과 같이 문서 수정부터 이루어져야함
소프트웨어에 변화가 발생한다는 것
변화 제안서에 대한 요구사항을 다시 정리 	> 변화 제안서 수정
					            > 요구사항 설계서
> 소프트웨어 개발

애자일의 경우 문서 업데이트의 비중이 적을것임

13-14 Change implementation
조직적 관점
- 최초 릴리즈 팀과 업데이트evolution 팀이 다를 수 있음. 
> evolution 팀에서
첫 단계로 다른 사람이 짠 프로그램 이해가 필요함
: evolution 팀은 문서가 많은 plan-based 프로덕트를 선호할수도 있음. 
릴리즈 되어있는 소프트웨어를 하나하나 읽어야하는 고충

ex)
고객이 직접 evolution 하겠다고 하는 경우
개발 완료 이후 별도의 evolution 계약을 다시 하는 경우 > 별도의 evolution팀에서 담당

-같으면 개발 과정의 반복일 뿐
개발팀이 evolution을 하면 됨
ex) 직접 개발해서 직접 사용하는 경우 

15 Urgent change requests
emergency repair process
ex)
시스템 고장
운영체제 문제 야기
법적 조치를 당하는 환경 변화 발생

바로 코드를 급하게 고쳐야함
but, 다음에 반드시 요구사항을 업데이트 해야함, 
그래서 플랜베이스, 탑다운에서>개발하고 문서 업데이트 안 해서 코드 꼬여버릴수도
> 시간이 지나면서 품질이 떨어질 수 있음

16 The emergency repair process
(이미지)

17 Agile methods and evolution
팀이 같다면. 원래 인크리즈멘탈 하기 때문에 
릴리즈를 한 페이즈에서 다시 요구사항 반영해서 evolution 하면 됨
Agile, development 하고 sprint 하게 되면 문제가 없다.

TDD 가 같이 이루어지고, 자동화 테스트 툴 사용하면 됨.

TDD + 애자일 > 반복적 모델을 통해 조금 더 수월할 수 있음

18 Handover problems
개발팀과 유지팀에서 서로 다른 개발 방법일 경우!

- agile-planbased: evolution 
유지팀이 문서를 요청하지만 개발팀은 agile에서는 만들지 않았다.
유지팀이 개발티에 문서를 요청하지 못할 확률 높움 > 직접 문서를 만들어야할 것임
- planbased-agile: evolution 
애자일, 유지팀이 테스트 코드를 요청
개발팀에게 요청 or 업데이트팀에서 직접 개발
>유지팀에서 refactoring과 simplified가 안 되어 있을 거라고 생각할 수 있음.
(애자일에서는 위 과정을 반드시 하지만, 플랜베이스에서는 하지 않았을 수 있다)

Legacy systems
19 Legacy systems
오래된 시스템. 기술들, 하드웨어
21 The elements of a legacy system
소프트웨어 : 자체가 오래된 언어로 만들어짐
하드웨어 : 단종, 기술지원 x 부품x
운영체제 : 더 이상 업그레이드 x, 단종
데이터 : 데이터베이스 단종, 파일시스템 x
비즈니스 프로세스 : 비즈니스 프로세스 자체가 오래됨, 시대착오적
 
22 Legacy system components
하드웨어가 더 이상 지원안됨
소프트웨어 os 라이브러리 단종, 기술지원x
더 이상 언어가 쓰이지 않음 , 언어 버전업x, 개발자 x
비즈니스 프로세스 : 소프트웨어 자체가 비즈니스 프로세스의 한 부분
제약과 수성
24 Legacy system layers
(이미지)
25 Legacy system replacement
완전히 새로운 시스템으로 대체  > 잘 안 쓰임, 보수적임
비쌈
위험함
설계서, 명세서가 없음. ＞급하게 수정한 소프트웨어에 대한 내용이 설계서에 명시되어있지 않은 경우
돈 들어감
문서화되지 않은 비즈니스 룰이 레가시 시스템에 임베디드 되어 있음
시스템과 비즈니스 프로세스가 긴밀하게 연결돼 있음
 
26 Legacy system change
legacy system을 바꾸는 것 비싸다
바꾸는 것 > 이미 있는 프로그램을 이해하고, 필요한 부분에 필요한 내용을 적용
programming style이 consistent 하지 않음 > 시대착오적
구식 언어를 사용하는 사람들이 별로 없음
최초의설계서들이 부정확할수도
성능 저하 발생할수도. > 옛날에는 하드웨어 성능 안좋아서 성능을 좋게 하기 위한 꼼수 부렸으나 최근 널널한 하드웨어 사용하는 사람들은 이해를 못 함.
데이터 에러, 중복과 일관성 없음
27 Legacy system management
그렇다면 회사에서 이 오래된 프로그램을 어떻게 처리할 것인가?
레거시 시스템에 의존하는 조직은 이 시스템들을 발전시킬 전략을 골라야 함.
이게 왜 필요한지 비즈니스 프로세스를 이해해야 함. 이 비즈니스 프로세스를 다른걸로 대체할 수 있다면? 그 비즈니스 프로세스를 위해 남아있는 프로그램을 날려버릴 수 있다. but, 아니면 어쩔 수 없이 시스템을 계속 유지해야 함.
유지하는 것이 이전보다 쉬워짐 > 시스템은 유지하고 동작할 수 있는 운영체제만 있다면 버츄얼 머신에서 돌림
re-engineering으로 maintainability 하거나, 아니면 그대로 냅둘수도 잇음
아님 갈아엎음 > 비즈니스 프로세스는 그대로 있고 그것을 위한 전체 시스템을 다시 구축
28 example of a legacy system assessment

기술적 측면에서 시스템의 퀄리티, 비즈니스 관점에서 비즈니스적으로 얻을 수 있는 가치에 따라 어떻게 할지 결정함
low quality : 유지보수에 너무 많은 비용이 든다.
hight : 안정적, 유지보수 비용이 크게 부담이 되지 않는다
low business value : 경제적인 이득이 낮음
L-L : 없앰
H-L : COTS, 상용장비로 대체. 혹은 날리거나 유지
굣님 생각 : 비즈니스적으로 돈을 벌고 있긴 하기 때문에 유지(보수적 접근),
비즈니스 상황이 너무 나쁘면 날리기, 개발팀축소 > 상용장비 가져오기
L-H : 비즈니스 상호아이 좋기 때문에
re-engineering or replace– 새로운 시스템???
H-H : 그대로 사용
30 Business value assessment
비즈니스 가치 어떻게 측정?
여러 관점
엔드유저, 실 사용자
고객
Line, IT, Senior managers
다른 stakeholder 이해관계자들을 인터뷰
31 Issues in business value assessment
비즈니스 가치를 판단하는 기준
사용하는 사람들의 수와 사용 빈도
business value
System dependability : 시스템 안정성
시스템의 안정성이 떨어진다 > 비즈니스 자체가 무너질수있다
system outputs : 시스템의 아웃풋, 돈을 많이 버는 시스템
32 system quality assessment
시스템 퀄리티 어떻게 측정?
33 business process assessment: 비즈니스적으로 의미가 있느냐
시스템이 실현하고 있는 비즈니스 프로세스 자체가 의미가 있느냐 판단해보자
레거시 시스템을 활용하고 있는 사람들 –skateholder-를 만나서 확인.
이게 무엇인가. 이 비즈니스 프로세스가 무엇인지 근본적 질문
동일 목적을 가진 작업이 두개이상의 프로세스에서 이루어지고 있는지 확인. 중복성이 없는가.
비즈니스 프로세스가 변형이 되거나 적용되는 것들이 필요한지 확인
이 비즈니스 프로세스가 필요한지 안한지. 다른 비즈니스와 상관관계
현재 시스템이 이 비즈니스 프로세스를 제대로 지원하고 적용하고 있는가?
레거시 시스템의 비즈니스 시스템이 활용도가 있느냐.의미가 있느냐
예시 : 여행 ordering system은 웹 기반 ordering이 널리 퍼져 있어서 사업 가치가 낮음.
34 Factor used in enviroment assesment : 환경적 요소 초점
supplier stability: 공급자가 안정적이여야 함, ex) 컴퓨터, gpu부품, 특수한 목적의 DB, library..
Failure rate: failure 많이 일어나면 비용 올라감 ex) 아무 이유없이 재부팅 하고, 꺼지는 등..
Age: 낡을수록 위험부담 늘어남
Performance: 필요한 성능에 맞출 수 있는가
Support requirements: 필요할 때 응대 해줄 수 있는지. ex) 외국장비를 사용하고 있을 때 한국 지사가 사라진다면?
Maintenance costs: 라이센스비나 하드웨어 유지비용 등등... 낡은 하드웨어는 높은 유지 비용이 듦 ex) 업데이트나 패치를 받는 비용
Interoperability: 다른 컴퓨터와 얼마나 잘 연결되는지
Factor used in application assesment : 어플리케이션의 퀄리티 초점
Understandability:이 소스 코드를 이해하기 얼마나 여렵냐.
Documentation: 문서가 있냐 없냐. 워드프로세서가 없는 시절에 만들어진 프로그램들도 있음.
Data: 데이터를 유지하는 게 가능한가
performance : 필요한 성능에 맞출수 있는가. 증가하는 수요에 맞춰 성능을 높일 수 있는가?
Programmina language:컴파일러나 인터프레터가 있느냐. 이것들이 발전할 것인가?
Configuration management: 릴리즈를 할 때 돌아가는 소프트웨어들을 하나로 묶어 빌드하는 것과 버전 컨트롤등이 제대로 이루어지고 있는가?
Test data: 테스트 코드로 시스템에 문제가 없음을 확인할 수 있는가? ex) 새로운 코드를 추가했을 때 이전 코드에 문제가 있는지 계속 확인할 수 있어야함
Personnel skills: 소프트웨어를 운영할 수 있는 사람이 있을까. 해당 개발 환경을 이해할 수 있는 사람이 있는가?
38 System measurement
이 소프트웨어, 시스템에 손을 댔을 때 발생하는 영향을 정량적으로 표현해보자
System measurement: 어플리케이션 시스템의 품질을 평가하기 위한 양적 데이터를 모아야 함
시스템 변경 요청의 수: 늘어날수록 품질 떨어짐 > 소프트웨어에 문제 or 비즈니스프로세스의 문제
다른 소프트웨어와 얼마나 많이 연결되어(interfaces)있느냐 ex) 많이 연결되어있을 경우 부담이 큼. 인터페이스만 하는 모델을 활용
시스템에 쓰이는 데이터의 양 : 많아지면 비일관성과 에러 늘어남.
옛 데이터를 정리하는건 비싸고 오래걸림. > 기존의 시스템을 변경하면서 데이터의 형태가 바뀌었다면? 올드 데이터를 새로운 형태의 데이터로 변경해야함
 
39 Software maintenance
40 Software maintenance : 유지보수, 고유명사, 꼭 알아함
소프트웨어 수정하는것. 특히 작은, 커스텀 소프트웨어를 바꾸는 것.
maintainence는 메이저한 수정x. 주로 작은, 마이너 체인지
기존 컴포넌트를 수정하거나 새 컴포넌트를 추가. 전체적인 아키텍처 건드리지 않음, 이런 대대적인 공사 x
새로운 기능을 넣을수도 있지만 새로운 기능으로 인해 전체적인 아키텍쳐 구조 변경 x
41 Types of maintenance
Fault repaires(24%): 버그, 프로그램이 테스트에서 걸러내지 못한 오류를 고치는 것
Enviromental adaption(19%): 새로운 하드웨어나 운영체제 위에서 돌리는 것, 프로그램이 돌아가는 환경이 변경되는 상황
Functionally addition and modification(58%) : 새로운 기능이 설계과정에서 추가되지 못해서 추가 수정 삭제하는 경우
43 Maintenance costs 유지보수 비용
개발비용보다 큼 2배에서 100배
기술적, 비기술적 요인에 영향받음 ex) 법규 규정 변화, 소프트웨어 비즈니스 변화
소프트웨어가 유지보수 되면서 성능 저하 발생, 구조문제 발생 가능
ageing될수록 유지보수 비용 증가할 수 있음
유지보수를 위한 비용이 더 비싸짐 > 새로운 시스템을 개발하는 것 보다 유지보수 팀이 더 평가 절하 되고 있는 경우가 많기 때문
45 Maintenance prediction
어느부분이 가장 많은 Maintenance를 필요로 할까. 돈은 얼마나들까.
Change를 받아들이는 것
Change는 시스템의 성능 degrade > 유지보수 할 것이 더 많아짐
유지보수를 하면 할수록 유지보수 할 것이 많아짐(변화 횟수 등에 영향을 받음)
47 Change Prediction: 변화를 많이 일으킬 부분을 예측해봄
유지보수 cost가 많이 나올, 변화를 많이 일으킬 부분 예측
Factor influencing this relationship
system interfaces, 소프트웨어가 가지고 있는 다른 것들과의 상관관계의 수와 복잡성
inherently volatile system requirements: 회사내규 나 법령, 사회적 인식 때문에 바뀌어야 할 때
business processes where the system is used: 이 소프트웨어가 투입된 비즈니스가 어떻게 돌아가는지 알아야 함.
48 Complexity metrics: maintainability prediction 시 시스템 컴포넌트의 복잡성에 따라 평가되기도 함 > 평이, 누구나 읽을 수 있고 간결한 코드 선호
depends on
컨트롤 구조
자료 구조의 복잡성,
오브젝트, 메소드, 모듈의 크기
49 Process metrics : 유지보수 프로세스가 잘 돌아가고 있는가?
얼마나 많은 change request가 요청되었는지
change가 주는 영향에 대해서 분석하는데 걸리는 시간
change를 구현하는 시간
처리되지 않고 쌓여 있는 change request
50 Software reengineering : 소프트웨어 개선
Structure을 다시 만드는 것이 대부분. function이나 메소드는 잘 안 바꿈
일부분을 수정함.
re-documented, 설계서를 다시 만든다.
51 Advantages
Reduced risk : 새로운 걸 만드는 것보다 안정적.
Reduced cost
52 The reengineering process

53 reengineering process activities
source code translation: 코드를 새 언어로 바꿈
Reverse engineering : 문서를 새로 만드는 것
program structure improvement: structure 개선.
program modulation: 프로그램 구조 재구성. 중복성 제거
data reengineering : 데이터 중복성 제거, 데이터 골격 수정
54 Reengineering approaches
automation은 매우 제한적 대부분은 manual하게 진행될 가능성 높음
 
55 Reengineering cost factors
소프트웨어 품질
자동화된 툴이 있는가?
데이터 영역을 건드려야 하는가?
할 수 있는 사람이 있는가? (특히 old tech)
56 Refactoring
프로그램 수정(improve) > 성능 높임, 복잡성 낮추기, 구조 수정
57 Refactoring and reengineering
reengineering은 단계를 거쳐서 시스템이 릴리즈 된 후 maintenance 단계에 들어갔을 때.
refactoring은 continous process(ex.애자일) 개발 프로세스가 스파이럴하게 계속 이루어질 때의 한 단계.
현실적으로 현직에서는 두 단어를 거의 동일하게 사용함.
58 Bad smells in program code
중복 코드 – 함수, 메소드로 만들기
긴 메소드
switch statements: 중복된 구문. 중복성 발생
Data clumping: 데이터 중복성
Speculative generality: 미래에 필요할 것을 예측해

chapter 22
애자일, 워터폴 모두에서 사용할 수 있는 방법론에 대해서 배울 예정
얼마만큼의 돈, 인력, 시간안에 일을 할 것인가 계획을 세우는 방법
 
쫄딱망한 프로젝트
OS/2 - 데스크탑 운영체제, 기술적으로 많은 시도를 했지만 망했다. > 윈도우가 만들어짐
Multics - time sharing, 멀티 유저, 멀티 펄포즈, 멀티 프로세싱 운영체제 > UNIX가 만들어짐
Man/month?
워터폴과 애자일 방식은 매우 큰 차이가 있다.
Waterfall에서는 머릿수
Agile에서는 사람을?
그 차이점에 대해서?
망해가는 프로젝트의 특징?
잘 보고 교훈을 느끼고 피해야 한다.
관리팀과 개발팀은 왜 서로 이해하지 못하는가?
MS Project를 활용한 거북선 제작 프로젝트
WBS(work break-down structure): 프로젝트의 추진 목표를 통제 가능한 수준으로 분류한 작업 목록
주공정 시뮬레이션:
주공정(critical task): 프로젝트에서 일정을 가능한 한 빨리 또는 제 때에 마치기 위해서 통제해야 하는 작업. 수많은 작업 중 가장 일정에 영향을 많이 끼치는 부분
작업량 고정: 작업이 많아졌는데 일정을 지켜야 한다면, 작업량 고정 기능으로 투입 인력을 예측할 수 있다.
작업량이란 하나의 작업에 투입되는 인적 자원의 시간적 총 투입량을 의미
 
주 키워드: Gantt chart. WBS, 주공정, 작업량, 인적 자원
특이점 : 위 내용에서 투입되는 사람들에 제한이 없음. 즉, 누구든 상관없음.
Man-month : 사람을 얼마나, 한 달에 얼마나
1사람이 1달동안 할 수 있는 일 1M/M
1사람이 12달동안 할 수 있는 일 12M/M > 12사람이 1달
이러한 정량적인 계산에 대해서 부정적으로 보는 견해가 많음
어떤 것을 주의해야하는 지 알아야함
 
The mythcal man-month
지연된 과제에 사람을 투입하면 더 지연된다.
소프트웨어 개발 과정에서, 추가 인력이 투입되면 교육하고 하느라 기존 인력이 낭비될 수 도 있음
소프트웨어 작업을 man-month로 measuring 하는 것 자체가 신화이다.
Complexity: 과정 자체가 complex함. 소프트웨어 개발자체를 딱딱 끊을 수 없으며, 개발자들 간의 커뮤니케이션이 반드시 있어야 하고, 매일 매일 일들이 동적으로 생기고 없어지고가 발생한다. 이것을 간트차트로만 나타낼 수 없다. 간트차트에 작성된 액션과 이것을 수행할 사람을 연결하기도 쉽지 않음.
새로운 사람이 추가된다는 것은 그와 다른 사람들과 커뮤니케이션을 해야함, 더 많은 사람과 커뮤니케이션을 해야할 필요성이 생김, 이는 그 사람들의 특성을 알아야 함. n명과 대화를 나누어야 하니 더 많은 커뮤니케이션이 필요함 > 기존의 대화 양이 늘어남, 그 사람을 알아가는 시간이 필요함, 신입이라면 교육 시간이 필요함.
소프트웨어 개발 프로젝트는 간트차트처럼 무 자르듯이 할 수 없고, 커뮤니케이션이 있어야 개발이 가능한데, 사람이 추가되면 대화할 사람이 늘어나고 뭘 할 수 있는지 파악해야 함.
No silver bullet : 소프트웨어에는 ‘비장의 무기’ 가 없다. 즉, 소프트웨어 개발에 있어서 정해진 한 방법은 없다. 그때그때 도구 개발 방법론을 조절해야 함. 그 문제를 수행하는 사람들이 상황에 맞춰 고민해야 함
The second-system effect : 첫 번째 시스템에서 아쉬운 것 다 집어넣어서 괴물을 만든다. over-engineering 때문에 느려지고, 커지고, 경쟁력이 떨어지고 결국 실패함
error, bug : 버그는 항상 존재, 치명적이지 않도록 자잘한 버그들이 일정수준 이하로 유지가 되어야 한다.
Progress tracking : 주기적으로 촘촘하게 이야기하면서 해결했다면 일정지연이 없었을 것이다. 조그만한 일 단위로 끊임없이 계속 만나서 해결해 나가라 그렇지 않으면 쉽게 일정이 지연될 것이다.(애자일에서 스크럼을 하는 이유) 태스크, 동료들간의 관계를 수시로 점검하여 혹시 발생할 큰 지연을 막을 수 있다.
Conceptual integrity: 조직 문화
프로그램에서 뭘 넣을건지, 뭘 뺄건지.
사용하는 사람이 별도의 교육 없이도 사용할 수 있어야 함 > 직관적, 구조가 단순 명확 순수
누군가는 방향, 철학에 대한 큰 그림을 그려야 함. 철학에 맞지 않다면 좋은 아이디어더라도 쳐내야 할 필요성이 있음. 개발 철학 > 이 철할을 다른 팀원들도 동일하게 가지고 있는가도 중요하다.
The manual : 소프트웨어 개발을 시작하는 시점에서 상세한 규격, 즉 어떠한 기능을 해야하는지 사용자에게 어떤 uiux를 제공해야하는지 디테일한 외부 내부적인 부분에 대한 설명, 만들 소프트웨어에 대한 요구사항 작성. 팀으로 작업할 때 어느정도 팀원 전체가 인지해야하는 내용이 있다.(워드 프로세서, 화이트보드에 그림그리는 것들도 포함됨) 구체화 작업 > 사용자와 팀원들의 피드백에 의해서 계속 진화함
The pilot system
실제로 고객에게 가는 것이 아님 기술이 가능한지 지향하는 목표가 맞는 건지 확인하는 용도
버려질 것임, 가장 중요한 것들만 구현해봄
정성, 정량적인 고민을 이게 맞는지 틀리는지, 어느 정도에 도달했는지 확인하는 시스템
이 단계를 거치지 않으면 파일럿 수준의 시스템이 고객에게 제공될 수 있음
가능하다면 파일럿을 통해 생각한 철학, 유저 인터페이스의 유용성등에 대해서 확인하자
Formal documentation
프로젝트의 목적, 성취 방법, 누가 성취할까, 언제까지?
본인들을 소개하는 문서 > 새로운 사람이 왔을 때 프로젝트에 대한 이해 어느정도 개념을 터득할 수 있다.
명확하게 어떤 프로젝트를 어떻게 진행하며 무엇을 성취할 것인지 기록할 필요가 있음
Project estimation
소프트웨어에 관련된 지식으로 소프트웨어에 관련된 일의 복잡도 일의 난이도와 누가 할수 있는가에 대해서 고민해야함 > 이것을 충분히 이해하고 일정을 잡아야함
쓸데없는 미팅 등 시간을 줄임
Communication
communication을 어떻게든 원활하게 해야 함.
물어볼게 있으면 물어봐야 > 예측하거나 상정하지 마라
커뮤니케이션을 통해 불필요한 지연, 오류를 줄일 수 있다.
The sugical team : 외과 수술팀
한 명의 좋은 프로그래머가 있는 것이 5배에서 10배의 생산성이 있다.
Code freeze and system versioning
Code freeze : 쓸만한 버전이 나왔을 때, 더 이상의 수정은 없다고 선언하는 것
system versioning :
소프트웨어를 개발하면서 사용자들에게 피드백을 받고 개발자들의 피드백으로 이루어짐
버저닝을 계속 하는것
Specialized tools
훌륭한 도구는 생산성, 결과물의 퀄리티 향상.
모두가 불편한 게 있으면 도구를 만들어야 함.
Lowering software development costs
아키텍쳐를 완료한 뒤 개발자를 고용해라 (워터폴일 때)
가장 좋은 방법은 소프트웨어를 만들지 마라(off the shelf)
 
정부 과제, 갑을 관계 의뢰 등으로
man-month, 간트차트, wbs등에 대한 이야기 나올 수 밖에 없다.
 
<책>
유닉스의 탄생
mastermind of programing
iWoz
닌텐도 이야기
the phoenix project

chapter 23
Chapter 23 – Project planning
Topics covered
- Software pricing : 소프트웨어의 가격을 매기는 법
- Plan-driven development : 계획은
- Project scheduling : 계획을 디테일하게 수립
- Agile planning : 애자일의 경우는?
- Estimation techniques : 추정 방법
- COCOMO cost modeling : 추정 수식

1. project planning
가. 무엇인가?
1) 프로젝트를 수행하기 위해서 해야 하는 일들을 잘게 쪼갠다.
2) 잘게 쪼개진 일들을 어떤 사람에게 할당할 것인지, 그 사람이 얼마나 해야 하는지 결정, 사람이 없다면 어떤 사람들이 얼마나 어느 정도 시간 동안 필요한가? 
3) 고려해야 할 위험 요소(사람, 환경 등) 예측 후 중요도에 따라 분류
4) 미리 예측 가능하게 정리 후 그에 따른 대응 방법을 준비해야 함
나. used to
1) 대내외적인 커뮤니케이션의 수단(어느정도 돈이 필요한지, 개발하려는 프로그램이 무엇인지와 어느정도 인력과 시간이 필요하고 걸릴지)
2) 제대로 계획대로 가고 있는지 체크하는, 매니지하는 역할
                   
2. Planning Stages
가. proposal stage: 고객에게 제안하는 단계, bidding for a contract(계약)
1) 고객이 제시한 requirement, 최고 가격, 기간등을 고려해서 작성 software requirement 개요 작성을 통해 계획(planning)을 짬.
2) setting a price, 프로젝트에 얼마나 많은 돈, 시간이 드는가, 이 단계의 목적은 가격을 정할 때 필요한 정보들을 고객에게 전달하는 것. 
플랜베이스드 입장에서 개발 팀 내에서 일반적으로 가격이 어느정도 인지 보는 경우가 있고, 가격이 얼마인지 경쟁을 하기도 함.  
애자일의 경우는 사람에 따라 많이 달라질 수 있고, 팀원들도 어느정도 인력과 시간 어떤 시스템인지 등 알 필요가 있다. 
3) 간접비, 운영비, 하드웨어, 개발 등에 필요한 가격을 정하는 것

나. project startup phase/planning : 해야할 일 정의, 어떤 일을 우선으로 둘지 정함. 확보할 개발자들을 투입하여 얼마 동안 누가 맡을 것인가? 디테일한 계획
1) 더 디테일한 requirement 조절, 수정
2) 인적, 물적 자원을 어떻게 투입 할것인가?돈하고 인력 투입 결정
3) 과제를 지속적으로 하면서 제대로 되고 있는지 지속적으로 확인
4) 애자일에서도 해당 과정이 필요하다. 스프린트가 돌면서 조금씩 확장되는 중 어느정도 플래닝이 필요하다.(회사의 자원을 사용하는 것이기 때문에)

다. Development planning : 프로젝트 중 중간중간 잘 되고 있는지 점검. 모니터링과 피드백. 컨트롤이 필요하다. 일정, 금액, 리스크에 대해 정기적으로 체크해야함
1) 정기적으로 개정돼야
2) 스케줄, 위험, 예상 비용들이 정기적으로 개정되아야함

3. Software pricing : 소프트웨어의 가격을 측정할 때 고려해야 하는 사항들
가. Software pricing
1) 인력 고용, 하드웨어, 소프트웨어, 간접 경비(여행, 회의, 교육비, 사무용품)를 고려해 예측
2) 개발 목적에 따른 조직적인 이유, 정치적, 비즈니스적인 이유에 따라 가격이 변동될 수 있음
3) 돌발 상황에 대한 대비를 잘 해야함
나. Factor affecting software pricing
1) Contractual terms: 개발자가 소스 코드에 대한 소유권을 갖게 되면 가격 낮아짐
2) Cost estimate uncertainty: 요구사항이 애매한 경우, 조직이 예상 산출에 미숙하거나 리스크를 놓친 경우 발생 가능(가격이 낮게 산출된 경우 왜 그런지 확인할 필요가 있다)
3) Financial health: 회사가 어려우면 계약에 필요한 돈이 낮아지거나 높아짐.(회사 상황에 대해서 미리 조사해야 함)
4) Market opportunity:  새로운 시장에 진입하려는 회사는 값이 낮아짐. 첫 번째 계약이 있어야 다음 계약을 이을 수 있음. 처음에 첫 진입을 위해서 매우 낮은 금액을 제시할 수도 있음.(투입되는 인적자원이 제대로 된 사람들인지 확인할 필요가 있음)
5) Requirements volatility: 요구사항이 변할 수 있음. 계약을 따기 위해 가격을 낮추고, requirement가 바뀌면 높은 가격을 매김
다. Pricing strategies
1) Under pricing: 스태프들에게 미래의 기회를 얻게 하기, 새로운 시장을 개척하기 > 이러한 경우일 때, 건실한 회사라면 계약을 해도 괜찮을 수 있음
2) Incresed pricing: 예상되지 않은 리스크에 대처하기 위해 가격을 올림, 초반에 너무 낮은 가격을 제시했다가 너무 많은 추가 요구사항으로 많은 가격이 올라가게 되는 것을 주의할 필요가 있다.
라. Pricing to win
1) 믿고 지불할 수 있는 가격을 만들어야.
2) 고려할 것이 적어지거나 실수가 생겼을 시 가격이 낮아질수도
3) 여러 요인에 따라 Additional costs may be added. 요구사항의 변화 등으로 인해 가격이 올라갈 수 있음

4. Plan-driven development
가. Plan-driven development
1) 규모가 큰 소프트웨어 개발 프로젝트의 경우에 씀. traditional way.
2) project plan이 1)해야될 것, 2)할 사람, 3)개발 스케줄, 4) work products(결과물이 무엇인가)를 기록한 문서를 만들어야 함. 
3) 매니저가 전담해서 일정되로 가고 있는지 확인하는 도구, 확인 문서로 사용
나. pros and cons: 무조건적으로 의미 없다 있다 하는 것이 아니라 지금 하고 있는 프로젝트에서 어느정도 플래닝이 필요할까 고민, 접근하는 것이 좋다.
1) 조직적으로 사람, 돈 등 투입되는 일이기 때문에 계획이 필요함
2) 앞으로 문제점 예상하지 못한 리스크들에 대해서 미리 고민하는 것
3) 빠른 사회적인 흐름에 맞춰 제공되어야 하는 순수 소프트웨어의 경우에는 맞지 않을 수도 있다. 
다. project plans
1) plan sections(guideline)
가)Introduction
가) Project organization
나) Risk analysis
다) Hardware and7 software resource requirements
라) Work breakdown 
마) Project schedule
바) Monitoring and reporting mechanisms

라. Project plans supplements(부수적)

1) Configuration management plan : 소프트웨어의 버전 관리, 빌드의 통일화
2) deployment plan : 반드시 들어가야할 것 같다(굣님 생각), 언제 어떤 결과물을 제시할것인가?
3) maintenance plan : 유지보수 어떻게?
4) quality plan : 프로그램이 제대로 만들어지고 있는가?
5) validation plan : 적절한 인적자원, 하드웨어 자원이 투입되어서 제대로 이루어지고 있는가?

마. The planning process
1) project planning은 반복적인 프로세스다. iterative process
2) 계획 변경은 피할 수 없다, 필수 불가결
가) 주기적으로 변경 사항을 찾고, 변경하고, 반영, 미리미리 리스크를 고민해서 문제없이 프로젝트가 진행되도록 해라
나) Changing business goals. 왜 이 소프트웨어를 개발해야하는 가를 회사적 입장에서 생각하고 비즈니스 트렌드를 미리 고민하고 조기에 제안 반영해라 
바. The project planning process
1) 이미지21페이지
2) 제약조건, 리스크, 마일스톤
3) 프로젝트 스케쥴링
사. Planning assumptions
1) realistic rather than optimistic, 이상주의자 보다는 현실주의자가 돼라(너무 낙천적인, 현실적으로 할 수 없는 계획x)
2) 미리 발생할 수 있는 리스크에 대해서 고민하고 미리 대안을 찾아두자,
3) 문제가 발생한 것을 대놓고 밝히고 스케쥴 변경을 해라, 스케줄 수행이 잘못된 것을 오픈하고 투명하게 고민해라
아. Risk mitigation
1) risk mitigation action : 미리 예측해서 최대한 없앨 수 있는 방안을 마련
2) 필요하다면 프로젝트를 다시 플랜해라.
3) 투명하게 리스크와 스케쥴 변경에 대해서 고객에게 오픈하고, 고객의 동의를 얻어라.

6. Project scheduling : 쪼갠 일들을 누가할지 결정
가. Project scheduling
1) 태스크 명확히 정의. 프로세스를 각각의 태스크로 조직허고, 언제 어떻게 수행될지. 누가 수행할지 정함.
2) 각 태스크를 완성할 캘린더 타임, 얼마나 걸릴지를 예상하고, 누가 태스크를 work 할건지.
3) HW,SW 자원을 각 태스크를 위해 얼마나 필요한지 예측
나. Project scheduling activitied
1) 프로젝트를 태스크에 따라 나눠서 시간과 자원을 예측
2) 연관성에 의해 태스크 간의 선후 관계를 정함. 최적의 노동력 사용.
3) 태스크 의존성을 최소화해 다른 태스크를 기다리는 딜레이 줄임.
4) 프로젝트 매니저의 경험과 직감 의존
다. Project scheduling process
1) 
2) 태스크 도출
3) 태스크들간의 선후 관계 정의
4) 인적 소프트웨어 하드웨어 적인 자원 배치
5) 사람에게 태스크 할당
라. Scheduling problems
1) 예측 자체가 힘듦
2) 해당 태스크를 몇 명의 사람이 할지 정하는 것이 쉽지 않음. 생산성은 사람 수에 비례하지 않음
3) 막바지 프로젝트에 사람 추가하면 커뮤니케이션 오버헤드 발생, 프로젝트 인원을 추가한다고 반드시 프로젝트 기간이 빨라지지 않는다.(커뮤니케이션 오버헤드 발생)
4) 예측 못한 일은 언제나 일어남
마. Schedule presentation
1) Graphic notation은 프로젝트 스케줄을 나타내기 위해 사용
2) 작업은 너무 작거나 크면 안됨. 1~2주 걸림
3) Calander-based : 시간 축을 항상 둔다.
4) Activity networks
가) Show task dependencies : 특정일과 다른 일과의 상관관게를 보여준다.
바. Milestones and deliverables
1) Milestone을 정함. 프로젝트를 진행하는 큰 틀 : 특정한 날짜에 뭐를 해야 하는지 점검하는 날.
2) deliverables : [고객에게 전달 되어야하는 날짜]
3) example 이미지


7. Agile planning
가. Agile planning
1) Iterative approch, 설계 개발을 반복
2) plan driven과 달리 functionality가 미리 예정되지 않고 decided during the development, 작게는 매일, 길게는 2-3주에 한번씩 개발해야하는 것을 정함
나. Agile planning stages
1) Release planning
가) 몇 달 후를 내다봄. : 몇 달후 릴리즈할 프로그램에 대해서 미리 계획
2) Iteration planning
가) 다음 increment를 계획. 2-4주에 한 번 정해짐.
다. Approaches to agile planning
1) planning in scrum
가) 3장에서 다루었음.
나) backlog(완성해야 할 것)를 daily review로 다루는 것에 기반
2) the planning game
가) Extreame Programming(XP)에서 발전됨.
나) 시나리오, 유저 스토리를 정해서 뭐를 먼저 개발해야 하는가에 달림.
라. Story-based planning
1) 스토리에 구현해야 할 특징들이 들어감. feature를 반영하는 유저 스토리에 기반
2) 시간이 얼마나 걸릴지 스토리들의 순위를 매김. 
3) 스토리의 규모와 난이도에 따라 effort points를 매김. 스토리를 구현하는데 복잡도 어려움 크기등을 고려함
4) velocity :팀이 주어진 시간 안에 할 수 있는 능력을 숫자로 환산한 것. velocity 예상에 따라 effort point per day가 측정됨.
5) 이것이 시스템 구현에 필요한 전체 effort가 예상되게 해 줌
마. The planning game
바. Release and iteration planning
1) Release planing
가) 어떤 특징이 구현돼야 할지. 이번 릴리즈에서 어떤 기능이 시스템 안에서 구현되어야 할지
나) 우선순위, effort point에 따른 구현될 스토리들의 순서
다) 약 2-3주에 한번씩 구현할 스토리들을 선정
라) velocity안에서 몇 개 스토리를 구현할 수 있을지.

사. Task allocation
1) 개발자는 개발 task로 스토리를 break down
가) task는 4-16시간
나) 개발자는 특정 태스크(어떠한 일을 언제부터 언제까지 할것인가)에 참여
2) 장점
가) 팀 전체가 overview 전체적인 개발자 사이의 이해 가능. 
나) 개발자가 책임감을 갖게 해 줌
아. Software delivery
1) Agile은 극단적으로 매일매일 소프트웨어가 나옴. 프로젝트 이터레이션이 끝나면 소프트웨어가 나옴
2) 날짜가 다가왔는데 feature 구현 못 할 시 일정 미루지 않고 릴리즈. > 소프트웨어가 딜리버리 되는 것이 중요하다.
자. AGile planning difficulties
1) customer에 의존해야 함. 소비자의 생각에 따라 개발 항목, 전체 일정이 바뀜
2) 소비자의 요청에 의해 다른 일을 우선시 해야 할 수 있음.
3) 소비자가 애자일에 익숙하지 않을 수도. 소비자가 생각한 순위가 애자일 과정에 의해 바뀌었을 때 소비자가 불편을 느낄 수 있음.
차. Agile planning applicability
1) small team인 경우, 개발자들이 각각 잘 알고 self motivated되어있는 사람인 경우 잘 돌아감
2) 대형 프로젝트를 진행하거나, 지리적으로 떨어지거나 다양한 팀이 협업 진행, 팀원이 자주 변경되는 경우 플랜베이스드가 필요하고 개별 팀에서 애자일이 이루어짐

8. Estimation techniques : 예측이 매우 어렵다
가. Experience-based approach : 매니저의 경험에 따라 판단
1) 수많은 경험을 통해 새로운 과제에 대해서 산출 > 시간이 흘러 기술을 발전하지만 유사한 과제들이 이루어질 때 유용 
2) Problem with experience-based approaches
가) 비슷하지만 조금 다른 소프트웨어에 대해서 비슷한 부분은 그대로 가져오고, 바뀌는 것 중심으로 토론, 토의 + 시대적 분위기. 경험 기반으로 판단.
나) 해 본 경험이 있는 사람이 없거나 완전 새로운 프로젝트라면 시행 착오 겪을 수 있음
다) 기존에 없는 새로운 것을 만든다면 반드시 시행 착오가 발생함
나. Algorithmic cost modelling
1) 예측하는데 가장 많이 언급되는 요소는 code size
2) 비용은 mathematical function으로 예측됨.
다. Estimation accuracy
1) 최종 사이즈에 영향을 미치는 것: 언어, 분산 시스템, 시스템이나 컴포넌트 재사용

9. Effectiveness of algorithmic models
가. complex하고 쓰기 어려움.
나. 가치를 예측하는게 정확하지 않음. 
다. algorithmic cost modeling은 적은 수의 큰 회사들에 국한. 특히 항공 우주 분야
라. 복잡하고 다양한 요소를 미리 고려할 수 있거나 고려해야 하는 시스템에서 사용(ex. 국방, 항공)

10. COCOMO cost modeling
가. 라인 수로 수학적으로 계산하는 듯
50분부터 10분정도


chapter 24
소프트웨어가 양적 질적 수준에 도달했는가 확인하는 작업
² Software quality 정의
² Software standards
² Reviews and inspections
² Quality management and agile development
² Software measurement 소프트웨어 품질을 정량적으로 측정하는 방법론

3 Software quailty management
소프트웨어마다 요구되는 레벨이 다름
소프트웨어의 퀄리티 측정 유지관리를 위한 프로세스, 절차 규정
일반적으로 사용할 수 있는 소프트웨어 퀄리티에 대해서
 
3가지 법칙
- 조직적으로 체계, 표준, 방침을 가지고 소프트웨어를 만든다는 회사 차원의 원칙이 있어야함
- 프로젝트 수준에서, 예정된 프로세스들이 잘 진행되고 있는지 체크해야 함.
- 프로젝트가 제공해야 할, 달성해야 할 품질을 달성하게 한다
 
4 Quality management activities
퀄리티를 측정 관리하는 팀은 개발팀과 독립적이다.
- 퀄리티팀은 개발 팀과 독립적. 객관적으로 바라볼 수 있게.
- 퀄리티 매니지먼트는 개발 프로세스와 독립적인 check.
- 프로젝트가 목표와 기준에 따르는지, 정성 정량적인 품질에 맞는지 확인하는 일
5 Quality management and software development
6 Quality planning
1) 만들고자하는 프로덕의 퀄리티는 정의
2) 제대로된 절차로 제대로 달성하고 있는 확인
3) 프로젝트 마다 고유의 달성해야할 퀄리티에 대해서 정의하고 측정 관리
 
quality plan는 회사에서 정의한 퀄리티 매니지먼트 프로세스와 스탠다드를 기반으로
특정 프로젝트에 특화된 퀄리티를 측정하고 관리하고 컨트롤하는 절차 
회사 전체 차원의 프로세스 스탠다드가 있어야함.
 
7 Quality plans
최대한 짧고 간결하게 해라 > 너무 길면 아무도 보지 않음.
 
8 Scope of quality management
퀄리티 매니지먼트는 크고 복잡한 시스템에서 특히 중요함. for large complex systems
for smaller systems 작은 시스템에서, 문서는 줄이고 개발팀 아니에서 퀄리티를 지키려는 퀄리티 문화를 만드는 것 quality culture를 만드는 데 초점을 맞춰야 함
 
9 Software quality
10 Software quality
Quality는 정한 바가 달성되었는지를 뜻함
소프트 웨어 시스템의 문제가 되는 것들
일부 quality requirement 들은 모호하기 때문에 명시하기 어렵다
명세서의 내용이 불완전하고 일관성 있지 않을 수 있음.
작성된 내용에 완벽하게 부합해야하는 것보다 동의한 수준에 도달했는지에 초점을 맞춰야 한다. fitness for purpose
11 Software fitness for purpose
적절하게 테스트 되었는가?
충분히 믿을만한가?
수용할 수 있는가?
쓸만한가?
구조가 잘 갖추어졌고 이해할만한가?
매우 애매한 용어들로 퀄리티를 확인하게 됨 > 프로세스를 정의하고 그 개발 프로세스를 준수하는 것에 집착하게 된다.
12 Non-functional characteristics
비기능적 기능들에 대해서도 객관화하여 판단하려고 함, 구체적인 항목을 뽑아내서 해당 항목에 대해서 달성하기 위해 노력
소프트웨어가 고객 입장에서 원하는 것이 아닐 때 > 다른 방법을 찾게됨
소프트웨어가 느리거나 신뢰하지 못할 경우 > 실질적으로 사용할 수 없음
13 Quality conflict
각각의 퀄리티 요소들 중 서로 상충되는 것 때문에 모든 요소를 만족시킬 수는 없음.
우리 프로젝트에서 가장 중요하게 달성해야하는 것을 퀄리티 플랜에서 선정해함
프로세스나 관리 항목 등은 위의 퀄리티를 잘 지킬 수 있는 것들로 편성
15 Process and product quality
퀄리티를 지키기 위한 프로세스를 준수
프로젝트에 특성화 되어있는 퀄리티 속성을 도출하고 지키기 위해 노력
소프트웨어 프로세스와 상품 품질을 추구하는 프로세스 사이에도 충돌이 발생할 수 있다
ex. 개발 스케쥴을 당기는 상황이 발생하면 퀄리티 체크가 2순위로 밀려 나기도 함.
16 process-based quality(process evolving)
프로세스가 진화함
17 Quality culture
Quality managers
팀원들에게 책임감을 갖게해야함.
professional behavior을 북돋워야함.

18 Software standards : 소프트웨어의 퀄리티를 매니지하기 위한 스탠다드(법규)
19 Software standards
프로덕, 프로덕 프로세스에 대한 규정
국제적, 국내적, 조직적 standard를 따를 필요가 있음
20 Importance of standards
best practice: 경험을 기반으로 실수를 줄이고 품질을 올리는 법을 정함.
framework, 체계화된 것으로 본인의 프로젝트에 맞춰서 일부 수정하여 적용. defining what quality means in a particular setting
continuity: 지속 가능성.(new staff can understand the organisation by understanding the standards that are used)
21 Product and process standard
product standard: 퀄리티 매니지먼트가 이루어졌다는 증명이 될 수 있는 문서
양식을 다루는 것. 문서 양식이나 ex. 요구사항 명세서의 목차, 문서 템플릿
코딩 양식
process standards: 개발 동안 따를 프로세스를 정함. 소프트 웨어 도구 등을 정하는 것.
22 example
23 Problems with standards
개발자 입장에서 오래된 거라고 느껴질 수 있음.
너무 양식이 강화되면 개발자가 필요성을 못 느끼게 될 수도 있음.
24 Standard development
왜 만들어졌는지에 대한 이해가 필요하다
Review standards and their usage regularly : 시대, 기술, 개발자에 맞추어서 주기적으로 업데이트 되어야한다.
가능한 자동화된 소프트웨어를 만들어 스스로 이루어지게 하고 개발자는 순수하게 소프트웨어에 집중할 수 있게 하는 것이 좋음.
25 ISO 9901 standards framework
국제 표준
소프트웨어를 개발하는 팀에서 소프트웨어의 퀄리티를 매니징하는 절차와 표준이 있는지를 따짐
소프트웨어 개발 표준을 위한 프레임워크 > 일반적인 표준들 > 이것들을 이용해서 회사에 맞게 구체화 하는 작업이 필요하다
26 ISO 9901 Core processes
27 ISO 9901 and Quality management
28 ISO 9001 certification
품질관리가 잘 되어있으면 ISO 9000 certify, 인증 해줌.
일부 custormer은 ISO 9000 인증 받아오라함.
29 Software quality and ISO 9001
ISO 9001의 보증, 인증이 부적절하기도 함
그 회사에서 지키는 프로세스일뿐, 개발할 소프트웨어와 100% 부합하는지 알 수 없다.
절차는 잘 따르지만 정성/정량적인 항목에 대해서 해당 소프트웨어를 제대로 관리하지 않았다면 제대로된 소프트웨어가 나오지 않을 수 있음
불완전한 software testing으로 기준이 달성될 수도
30 Reviews and inspections
31 Reviews and inspections
소스코드를 지켜보고 문제를 찾아 개선하는 것임
반복 진행하고 다음 단계로 가도록 승인(signed off)
product 프로덕트의 문제가 없는가
product and process 프로세스의 진도, 체계적으로 거쳐야할 단계를 잘 지키고 있는가
quality reviews 퀄리티를 잘 지키고 있는가
32 Quality reviews
코드 포함 디자인, 사양서, test plans, standards들을 리뷰함.
signed off
33 Phases in the review process
Pre-review activities : 계획, 준비과정
The review meeting
리뷰 팀이 따로 있으면 소프트웨어를 객관적으로 리뷰, 볼 수 있다.
Post-reviews activities
문제 전달, 개선
34 도표
35 Distributed reviews
face to face 면대면 미팅을 권장함
36 Program inspections
개발자들이 상호 리뷰 or 페어 프로그래밍
소스코드를 실행하기 전에 눈으로 보고 코드를 확인하는게 중요.
37 Inspection checklists
Common error(일반적으로 코드에서 발생하는 에러들) 확인하는 checklist-> 미리 사전에 체크하면 시간적으로 효율
특정 언어에서 흔하게 발생할 수 있는 에러, 코딩 스타일 가이드를 어긴 것들이 체크리스트에 들어갈 수 있음.
type cheking(코드 인스펙션이 이루어지기 전에 미리미리 이루어지는 체크사항)이 잘 되면 효율적으로 코드 인스펙션이 가능.
38 inspection checklists
Data faults
Control faults
Input/output faults
Interface faults
Storage management faults : c++와 같은 프로그래밍 언어를 인베디드를 짤 때 가장 중시하는 체크리스트 > 동적 메모리 할당을 할 때 발생할 수 있는 문제들
Expection management faults
lint: 소스 코드 레벨에서 타이핑과 동시에 문제를 인식할 수 있게 해 줌

40 Quality management and agile development
41 Quality management and agile development
Document-based 보다 informal함
quality culture를 세우는 것에 달림.
agile 커뮤니티는 ISO 싫어함
42 Shared good practice
Check before check-in: 스스로 코드 리뷰
Never break the build: 여러 소프트웨어가 합쳐지는 빌드 과정에서 한 사람의 코드로 인해서 해당 작업이 중단되면 안 됨
Fix problems when you see that
남의 코드에 문제가 있다면 직접 고쳐라, 문제를 전달하고 고치는 절차가 줄어든다
43 Reviews and agile methods : 자신의 코드 다른 사람의 코드를 계속 봐라
44 Pair programming
한 코드를 두명이 같이 돌아가면서 만듦
45 weakness
두 사람 모두 실수할 수 있음.
두 사람 모두 실수를 묻어버릴수도
파트너에게 의견을 표출하는 것을 꺼릴 수 있음
46 Agile QM and large systems
최소한의 문서가 필요하다.
agile이 비효율적일 수 있음. 문서가 적어서

47 Software measurement
48 Software measurement
정량적인, 정성적인 부분을 정량적으로 나타낼 수 있도록 노력. deriving a numeric value
비교 검증을 위해서
이 영역에는 established 표준적인 기준이나 규칙이 거의 없음
49 Software metric
Any type of measurement을 정량, 정성적 요소에 매칭
소프트웨어와 소프트웨어 프로세스도 정량적으로 평가.
product 자체에서도 지표를 찾고, 프로세스도 계량화된 수치로 추적, 관리
50 Types of process metric examples
특정 작업 하는데 걸리는 시간
프로세스에 필요한 자원(인력, 경비, 컴퓨터 자원)
동시에 실행되는 이벤트의 수 : 코드 인스펙션을 하는 동안 발생하는 문제들, 버그 리포트의 수, 코드의 라인 수
52 Use of measurements : 측정한 것을 어떤식으로 사용?
시스템 퀄리티 요소들에 가치를 할당.
ex_ 그래프의 복잡도 > 이게 높으면 유지하기 어려움
수치화 할 수 없는 부분들도 수치화
ex_복잡도가 높다 > 코드를 읽기 어려움, 버그가 많을 확률이 높아 신뢰도가 낮음
53 Metrics assumptions
상관관계를 통해 논리적인 접근을 할 수 있다
54 Relationships between internal and external software
소프트웨어에서 계량화 할 수 있는 internal attributes와 정성적인 external quality attributes를 연결
55 Problems with measurement in industry
표준이 없음.
대부분 회사들의 표준이 약하다.
수치화 과정이 개발과 별개이기 때문에 overhead(추가적인 일)이 일어날 수 있음
56 Empirical software engineering
경험적인 부분이 크게 작용함
개발자의 지식이 투영되어야 함->효율적으로 돌아간다. 재사용성이 좋다 등
57 Product metrics
product quality의 predictor
동적 접근 방식: 코드를 실행해서 측정. 효율성과 안정성을 측정
정적 접근 방식: 소스코드 자체 읽고, 정리. 
효율성, 신뢰성
복잡도와 understandability 읽는 것의 용이성, 유지 보수의 용이성 측정
58 Dynamic and static metrics
Dynamic: 응답 시간, failure 횟수 측정 쉬움
static: 복잡도, 이해 가능도, 유지보수성(maintainability 함수가 잘게 쪼개지고 클래스가 만들어졌는가?)
59 Static software product metrics
Fan-in/Fan-out: in은 호출하는 함수의 수, out은 호출 받는 함수의 수.
Length of code : 코드 길이
Cyclomatic complexity : 함수 안의 그래프의 복잡성
Length of identifiers: 변수 이름 길이가 적정해야 함
Depth of conditional nesting: 조건문의 레벨, 조건문 안에 조건문이 들어가면 복잡함
Fog index: 소프트웨어 안에 들어있는 워드의 숫자 세서 인덱스 만듦?
The CK objected-oriented metrics suite
Weighted methods per class: 메소드가 너무 많아도, 적어도 안됨
Depth of inheritance tree : 유전의 법칙에 의해 서브 클래스의 레벨이 어느정도 되는지
Number of children : 베이스 클래스에서 얼마나 많은 서브 클래스가 만들어지는가
Coupling between object classes : 클래스가 서로 호출하는 수
Response for a class : 한번 호출할 때 얼마나 많은 그 안의 함수들을 실행하는가
Lack of cohesion in methods: 하나의 메소드에 얼마나 많은 state가 연결되어 있는지.
63 Software component analysis
metrics로 옛날 프로젝트를 measurement한 것과 현재 기존의 프로그램에 적용한 것을 비교.
64 the process of product measurement
65 measurement ambiguity
정성적인 부분을 정량으로 매핑하는데, 본질적으로 이해를 잘하는 것이 중요함.
number of change에 대해서
소프트웨어가 좋지 않을 경우, 변경을 할수록 더 많은 문제로 인해 더 많은 체인지 요청이 발생함
소프트웨어가 좋은 경우, 많은 사람들이 사용하면서 더 많은 체인지 요청이 발생함
68 Software analytics : 소프트웨어를 실행하고 운영하면서 얻어지는 자동적으로 소프트웨어를 통해 얻어지는 데이터
실시간으로 사용자가 겪는 문제점과 문제가 발생했을 때의 환경 정보 수집
오픈 소스 소프트웨어 분석하고 공유
69 Analytics tool use
자동화하는 것.
easy, concise outputs 정보 간결, many mesurement 다양한 정보.
사용자와 인터랙티브 해야함
70 status of software analytics
아직 미숙함.,
이런 툴을 개발하는 것 자체가 기업에 부담이 될 수 있음
