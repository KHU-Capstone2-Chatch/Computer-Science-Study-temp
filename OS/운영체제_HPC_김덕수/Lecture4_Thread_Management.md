# 스레드

## 프로세스와 스레드
작업 : 목적을 하기 위한 연산 과정

1. 프로세스는 **자원**을 할당 받고
2. 그 자원을 **제어**해서 원하는 작업/목적을 달성하는 것

프로세스를 **1) 자원 2) 제어** 두 부분으로 나누어서 볼 때, <br>
프로세스의 제어만 분리하여 '스레드'라고 함
- 프로세스 안에는 여러개의 스레드가 있을 수 있다.
- 즉, 제어는 여러개 있을 수 있다.

## 스레드
- 리소스 영역
  - 코드
  - 전역 데이터
  - 힙 : 전역 데이터 저장
- 프로세스 영역(제어 영역)
  - 제어 정보
  - 지역 데이터 : 지역 내에서만 유효한 데이터
  - 스택 : 지역 데이터 저장
 
 **여러개의 스레드**로 이루어진 프로세스가 **하나의 자원**을 공유한다.

#### <스레드의 메모리 영역>
그림, 하나의 프로세스에 있는 스레드들은 동일한 메모리 주소 공간을 공유한다.

- 전통적 프로세스 = 단일 스레드 프로세스
- Light Weight Process(LWP)
  - 기존의 자원과 제어를 모두 포함하고 있는 전통적 프로세스(= 단일 스레드 프로세스)보다 가볍다. 
- 프로세서(ex. CPU) 활용의 기본 단위
- 구성 요소
  - Thread ID
  - Resister set(PC, SP..)
  - Stack(ie. 지역 데이터)
- 제어 요소 외 코드, 데이터 및 자원들은 프로세스 내 다른 스레드들과 공유 

## 단일 스레드 프로세스(Single-Thread) VS 멀티 스레드 프로세스(Multi-Thread)

## 스레드의 장점
### 사용자의 응답성


### 자원 공유
- 자원을 공유해서 효율성 증가 
- 커널의 개입을 피할 수 있음 > context switching 연산을 줄일 수 있음
> 두 프로세스가 하나의 자원을 사용하려한다면 context switching 발생
> 두 스레드는 자원을 공유하고 있기 때문에 동시에 사용 가능 > 이 때 스레드들의 자원 사용에 대한 처리가 필요하다

### 경제성
- 프로세스의 생성, context switch에 비해 효율적

### 멀티 프로세서 활용
- 병렬처리를 통해 성능 향상
> 여러개의 스레드를 통해 여러개의 CPU 코어를 동시에 사용

> 스레드의 사용의 예
> FPS 게임

# 스레드의 구현
- Multi-Threading Model
  - N:1 다대일 모델 > 사용자 수준 스레드
  - 1:1 일대일 모델 > 커널 수준 스레드
  - N:M(N>M) 다대다 모델 > 혼합형 스레드

## 사용자 수준 스레드(User Thread)
- 사용자 영역의 스레드 라이브러리로 구현됨
  - 스레드의 생성, 스케쥴링
  - POSIX threads, WIN32 threads, java thread API 

- 1:N 매핑

### 장점
- 커널은 스레드의 존재를 모름
  - 커널이 생성 및 관리의 부하가 적음, 유연한 관리 가능(오버 헤드가 낮음)
  - 이식성이 높음 > 어떤 스레드 라이브러리든 설치하여 사용 가능
 ### 단점
 - 커널은 프로세스 단위로 자원을 할당 (single-threaded kernel의 경우)
   - 하나의 스레드가 block상태가 되면, 모든 스레드가 대기해야함 


## 커널 수준 스레드(Kernel Threads)
- OS(Kernel)가 직접 관리
- 1:1 매핑
### 단점
- 커널 영역에서 스레드의 생성, 관리 수행
  - context switching등 부하가 큼(오버 헤드가 큼)
### 장점
- 커널이 각 스레드를 개별적으로 관리
  - 프로세스 내 스레드들이 병행 수행 가능
  - 하나의 스레드가 block 상태가 되어도, 다른 스레드는 계속 작업 수행 가능

## 혼합형 스레드
- N개의 사용자 수준 스레드 : M개의 커널 스레드 (N>=M)
  - 사용자는 원하는 수만 큼 스레드 사용
  - 커널 스레드는 자신에게 할당된 하나의 사용자 스레드가 block 상태가 되어도, 다른 스레드 수행 가능 > 병행 처리 가능
- 유연함 + 효율적 
