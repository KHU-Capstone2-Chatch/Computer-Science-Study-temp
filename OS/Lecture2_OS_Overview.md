# Lecture2 Operate System Overview
 
# 운영체제의 역할
- User Interface > 사용자가 시스템을 편리하게 사용할 수 있도록 함 (편리성)
  - CUI
  - GUI(그림 형태로 되어있는 인터페이스)
  - EICI(사용자가 편하게 시스템을 사용할 수 있도록 하는 특화된 인터페이스) ex) mpc 플레이어 인터페이스
- Resource management > 주어진 자원을 잘 활용하여 시스템을 운영 (효율성)
  - HW resource
  - SW resouce 
- Process and Thread management
 > *process : 실행의 주체 (추후 설명 에정) <br>
 > *thread : process 보자 작은 단위 (추후 설명 예정)
- System management > 시스템 보호

## 컴퓨터 시스템의 구성
OS
- Kernel : 운영체제의 핵심 (추후 설명 예정)
- System call Interface <br>
  - 사용자가 커널에 직접 접근해서 조작을 하게 되면 커널이 하드웨어를 제어하는데 문제를 일으킬 수 있음
  - 필요한 기능이 있으면 커널에 요청을 하는 통로
  - 커널이 제공하는 기능들 중 사용자가 사용할 수 있는 기능들을 모아 놓은 것들

## 컴퓨터 시스템의 구성

# 운영체제의 구분
## 동시 사용자 수
  - 단일 사용자
    - 한 명의 사용자만 시스템 사용 가능
      - 한 명의 사용자가 모든 시스템 자원 독점
      - 자원관리 및 시스템 보호 방식이 간단 함 
    - 개인용 장비 등 
  - 다중 사용자
    - 동시에 여러 사용자들이 시스템 사용 
      - 각종 시스템 자원들에 대한 소유권 관리 필요
      - 기본적으로 multi-tasking 기능 필요
      -  os의 기능 및 구조가 복잡
    - 서버, 클러스터 장비 등에 사용
## 동시 실행 프로세스 수
  - 단일 작업
    - 시스템 내에 하나의 작업(프로세스)만 존재
      - 하나의 프로그램 실행을 마친 뒤에 다른 프로그램의 실행 
    - 운영체제의 구조가 간단
  - 다중 작업
    - 동시에 여러 작업(프로세스)의 수행 가능
      - 작업들 사이의 동시 수행, 동기화 등을 관리해야 함 
    - 운영체제의 기능 및 구조가 복잡

## 작업 수행 방식 (사용자가 느끼는 사용 환경)
### 순차 처리 (No OS, ~1940s)
운영체제 개념이 존재하지 않았음
- 사용자가 기계어로 직접 프로그램 작성
- 실행하는 작업 별 순차 처리
  - 각각의 작업에 대한 준비 시간이 소요 > overhead
### Batch Systems, 일괄처리 시스템 (1950s ~ 1960s)
- 모든 시스템을 중앙에서 관리 및 운영
- 사용자의 용청 작업을 일정 시간 모아 두었다가(batch) 한번에 처리
- 시스템 지향적 : 시스템이 처리하기 편함, 시스템을 더 효율적으로 이용
- 장점
  - 많은 사용자가 시스템 자원 공유
  - 처리 효율(throughput) 향상 <= 시스템 지향적
- 단점
  - 생산성(productivity) 저하 : 같은 유형의 작업들이 모이기를 기다려야 함
  - 긴 응답시간 : 작업 제출에서 결과 출력까지의 시간이 김
### Time Sharing System, 시분할 시스템 (1960s~1970s)
- 여러 사용자가 자원을 동시에 사용
  - os가 파일 시스템 및 가상 메모리 관리 
- 사용자 지향적
  - 대화형(conversational, interactive) 시스템 : 완벽한 결과가 나오지는 않지만 일정 시간이 지나면 계속 반응이 있음
  - 단말기(CRT terminal) 사용 : 화면을 그려주고 입력을 전달해주는 역할
  - 장점
    - 응답시간 단축
    - 생산성 향상
      - 프로세서 유휴 시간 감소 : 프로세서가 쉬지 않고 일하게 함
  - 단점
    - 통신 비용 증가
      - 통신선 비용, 보안 문제 발생
    - 개인 사용자 체감 속도 저하
      - 동시 사용자 수 증가 > 시스템 부하 > 느려짐 (개인 관점)
### Personal Computing
다른 사람과 나눠 쓰지 말고 나 혼자 쓰고 싶다
- 개인이 시스템 전체 독점
- CPU 활용률이 고려의 대상이 아님 (지금까지는 CPU 활용률이 중요한 고려 대상)
- 사용자가 얼마나 편하게 시스템을 사용하는가가 더 중요한 고려 요소
- OS가 상대적으로 단순함
- 대신 다양한 사용자 지원 기능 지원
- 장점
  - 빠른 응답시간
- 단점
  - 성능이 낮음

### Parallel Processing System, 병렬처리 시스템 (Tightly-coupled system)
성능이 낮으니 하나의 컴퓨터에 여러개의 cpu를 넣자!
- 단일 시스템 내에서 둘 이상의 프로세서 사용
- 메모리 등의 자원 공유 (Tightly-coupled system) : cpu는 여러개, 기타 자원(기억장치, 주변장치)들은 공유
- 사용 목적
  - 성능 향상
  - 신뢰성 향상 (cpu하나가 고장나도 정상 동작 가능)
- 프로세서간 관계 및 역할 관리 필요

### Distributed Processing Systems, 분산 처리 시스템 (Losely-coupled system)
컴퓨터 한대 안에 cpu를 100개 넣을 수 있을까? > 공간적 시스템적 제약이 있음 <br>
컴퓨터를 여러대 붙이자! <br>
네트워크를 사용해서 컴퓨터 여러대를 묶는 방식
- 네트워크를 기반으로 구축된 병렬처리 시스템 (Losely-coupled system)
  - 물리적인 분산, 통신망 이용한 상호 연결 > 여러 컴퓨터를 하나로 묶기 편함
  - 각각의 컴퓨터(node)는 자신의 운영체제를 탑재
  - 각 컴퓨터는 **분산운영체제**를 통해 관리 (은페성, transparency)
  - ex ) 클러스터 시스템, 클라이언트 서버 시스템
- 장점
  - 자원 공유를 통한 높은 성능
  - 고 신뢰성, 높은 확정성
- 단점
  - 구축 및 유지보수 관리가 어려움

-

### Real-time Systems, 실시간 시스템
- 작업 처리에 제한 시간(deadline)을 갖는 시스템 : 제한 시간 내에 서비스를 제공하는것이 자원 활용 효율보다 중요 
- 작업의 종류
  - Hard real-time task : 시간 제약을 지키지 못하는 경우 시스템에 치명적인 영향 ex) 발전소 제어, 무기 제어
  - Soft real-time task : 동영상 재생
  - Non real-time task
  
# 운영체제의 구조

# 운영체제의 기능
