# 1 스케쥴링의 이해
## 1.1 스케줄링의 개념
스케줄리은 여러 플세스가 번갈아 사용하는 자원을 
어떤 시점에 어떤 프로세스에 할당할지 결정하는 것이다.

좋은 스케쥴링은 프로세서의 효율성을 높이고 
작업의 응답시간을 최소화하여 시스템의 작업 처리 능력을 향상 시킨다.

인터럽트 처리, 오류 처리, 사용자의 시스템 호출 등의 사전 처리는 스케줄링이 필요 없다.

> 다중 작업   
> 다중 프로그래밍과 상관 없이 여러 프로세스를 동시에 실행하는 것   
> 단일처리 시스템에서도 스풀링 등을 이요앻 열 프로세스를 동시에 실행할 수 있다.

## 1.2 스케줄리의 목적
- 자원 할당의 공정성 보장
- 단위 시간당 처리량 최대화
- 적절한 반환시간 보장
- 예측 가능성 보장
- 오버헤드 최소화
- 자원 사용의 균형 유지
- 반환시간과 자원의 활용간에 균형 유지
- 실행 대기 방지
- 우선순위
- 서비스 사용 기회 확대
- 서비스 수 감소 방지

## 1.3 스케줄리의 기준 요소
프로세서 버스트, 입출력 버스트

프로세서 중심 프로세스와 입출력 중심 프로세스를 적절히 혼합

## 1.4 스케줄리의 단계
1. 작업 스케쥴링(승인 스케줄링) : 작업 선택   
디스크에 있는 작업 중 프로세스화할 작업과 시스템에 들어갈 작업을 결정한다.
수행 빈도가 적어 장기 스케줄링에 해당한다.
2. 작업 승인과 프로세서 결정 스케쥴링 : 사용 권한 부여
프로세서를 사용할 권한을 부여할 프로세스를 결정하는 작업 승인과
할당 스케줄링이다.   
1단계 작업 스케줄링과 3단계 프로세서 할당 스케줄링의 완충 역할을 한다.
중기 스케줄링에 해당한다.
> 스와핑 기능의 일부로 이해할 수 있다.
3. 프로세서 할당 스케줄링 : 준비 상태의 프로세스에 프로세서 할당(디스패칭)
디스패처가 준비 상태에 있는 프로세스 중에서 프로세서를 할당할 프로세스를 결정한다.   
단기 스케줄링에 해당한다.

## 1.5 스케줄링 큐
- 준비 큐 : 프로세서를 할당받아 실행하려고 기다리는 프로세스들이 대기한다.   
- 입출력 장치 큐 : 입출력장치를 사용하려는 프로세스들이 대기한다.

큐는 프로세스 제어 블록을 연결 리스트로 연결하고 있는 형태이다.

입출력 장치 큐는 다양하게 추가할 수 있다.
> 테이프 드라이브나 시분할 단말기 같은 전용 장치의 경우
> 입출력 장치 큐는 프로세스 하나만 가질 수 있지만,
> 디스크와 같이 공유할 수 있는 장치는
> 입출력장치 큐에 여러 프로세스가 대기할 수 있다.

## 1.6 스케줄링과 스케줄러
### 1.6.1 큐잉 도표
1. 작업이 시스템에 들어오면 프로세스 제어 블록 생성   
2. 실행 준비가 된 프로세스가 준비큐에 들어감
3. 프로세스에 프로세서가 할당
    1. 프로세스가 입출력 요청을 보내고 입출력 큐 들어감 (준비 상태)
    2. 프로세스가 새로운 프로세스를 생성하고 생성한 프로세스의 종료를 기다린다. (준비 상태)
    3. 프로세스가 시간 할당량을 초과 하면 준비 큐에 들어간다.
    4. 인터럽트로 프로세서에서 제거된 프로세스는 다시 준비 큐에 들어간다.

### 1.6.2 스케줄러의 종류와 역할
#### 장기 스케줄러 (작업 스케줄러)
디스크에서 메모리로 작업을 가져와 처리할 순서를 결정한다.

> 장기 스케줄러는 시스템에 새로운 작업이 분 단위로 들어오므로 
> 상대적으로 드물게 수행된다.
> 작업이 시스템에 들어오는 정도가 일정하다면, 
> 장기 스케줄러는 작업이 시스템을 나갈 때만 실행하여 실행 간격이 길어지므로
> 실행 시간이 좀 더 길어도 영향을 받지 않는다.

#### 단기 스케줄러 (프로세스 스케줄링)
메모리에 적재된 프로세스 중 프로세스를 할당하여 실행 상태가 되도록 결정한다.

> 디스패처는 단기 스케줄러가 선택한 프로세스에 실질적으로 
> 프로세서를 할당하는 역할을 하는 모듈이다.
> 프로세스의 레지스터를 적재(문맥 교환)하고, 사용자 상태로 전환하고, 
> 다시 시작할 때 사용자 프로세스가 올바를 위치를 찾을 수 있도록 해준다.

#### 중기 스케줄러
프로세스들이 프로세서를 서로 차지하려고 할 때, 
프로세스를 별도의 기억 장소에서 빼낼 수 있어
다중 프로그래밍의 정도를 줄일 수 있다.   

시간이 흐른 후 빼낸 프로세스는 다시 메모리에 들어가 
실행을 중단했던 곳부터 다시 실행한다.
> 이 방법을 `스왑`이라고 하고,
> 작업의 혼합을 개선하거나, 
> 프로세스가 가지고 있던 메모리를 사용할 수 있게 하는데 필요하다.

## 1.7 선점 스케줄링과 비선점 스케줄링
'실행 중인 작업이나 프로세스를 실행 중 중단할 것인가?'

### 비선점 스케줄링
한 프로세스가 자원을 선택했을 때 다른 프로세스가 해당 자원을 빼앗을 수 없는 경우

### 선점 스케줄링
실행 중인 프로세스를 인터럽트할 수 있거나 준비 상태로 이동할 수 있는 경우

프로세스 하나가 장시간 동안 프로세서를 독점하는 것을 방지하여
모든 프로세스에 프로세서를 서비스할 기회를 느릴 수 있다.

우선순위가 높은 프로세스들이 긴급처리를 요청할 때 유용하다
ex) 실시간 시스템, 대화식 시분할 시스템 등의 빠른 응답 시간을 유지하고자 하는 시스템

> 오버헤드가 커질 수 있으므로, 이를 효과적으로 이용하기 위해서
> 메모리에 프로세스가 많이 적재되어 있어야 한다.

## 1.8 스케줄링 알고리즘의 선택 기준
- 프로세서 사용율
- 처리율 : 단위시간당 완료하는 작업 수
- 반환시간 : 대기시간 + 실행시간
- 대기시간 : 준비 큐에서 기다리는 시간 (작업이 메모리에 들어가기 까지 걸린 시간)
- 반응시간 : 작업을 요청한 시간부터 반응을 시작하는 시간(첫 번째 응답)

# 2 스케줄링 알고리즘
## 2.1 선입선처리 스케줄링 (FCFS, FIFP) - 비선점
### 특징
프로세서를 요청하는 순서대로 프로세서를 할당한다.

일괄 처리 시스템에서는 매우 효율적이나 
빠른 응답을 요청하는 대화식 시스템에는 적합하지 않다.

`효위 효과`로 인해 프로세서 중심 프로세스나 
입출력 중심 프로세스 중 한쪽으로 치우쳐 기다리는 불균형 상태가 발생한다.

> 호위 효과   
> 큰 프로세스 하나를 처리하여 프로세서를 떠나기를 기다리는 것,
> 즉 프로세서 중심 프로세스 하나가 프로세서를 떠나기를 기다리는 현상   

### 장점
### 단점

## 2.2 최소작업 우선 스케줄링(SJF) - 선점/비선점
### 특징
각 작업의 프로세서 실행 시간을 이요하여 프로세서가 사용 가능할 때
실행 시간이 가장 짧은 작업에 할당하는 방법이다.
> 프로세서 실행 시간이 동일한 경우 선입선처리 스케줄링 적용

주어진 작업 집합에서 평균 대기 시간이 최소이므로 최적 알고리즘으로 볼 수 있다.
> 실행 시간이 긴 작업은 뒤로 밀려 그만큼 대기 시간이 증가 하지만,
> 짧은 작업의 대기 시간이 줄어 평균 대기 시간은 감소한다.

### 선점형 : 최소잔여 시간 우선 스케줄링(SRTF)
`현재 실행 중인 프로세스의 남은 실행시간 > 새로운 프로세스 실행 시간` 일경우
새로운 프로세스가 프로세서를 선점한다.

### 장점
### 단점

## 2.2 우선순위 스케줄링 - 선점/비선점
우선 순위가 가장 높은 프로세스에 프로세서를 할당한다.   
새로운 프로세스가 준비 큐에 도착하면,
우선순위를 비교하여 큐에서 위치를 결정한다.
> 우선순위가 동일한 경우 선입선처리 스케줄링 적용

### 우선순위 정의 기준 내부적/외부적
- 내부적
    - 제한시간
    - 기억장소 요청량
    - 사용 파일 수
    - 평균 프로세서 버스트에 대한 평균 입출력 버스트의 비율...
- 외부적
    - 프로세스의 중요서
    - 사용료를 많이 낸 사용자
    - 작업을 지원하는 부서... 

### 선점형
새로 도착한 프로세스의 우선순위가
현재 실행하는 프로세스의 우선순위보다 높으면
새로 도착한 프로세스가 프로세서를 선점한다.

### 장점
### 단점
실행 준비는 했으나 우선 순위가 높은 프로세스가 계속 들어오면
우선순위가 낮은 프로세스는 무한정 기다려야한다. 
즉, 무한 정지, 기아 상태가 발생한다.

> 에이징   
> 우선순위 스케줄링의 기아 상태를 해결하기 위한 방법으로
> 시스템에서 오래 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 방법이다.
> ex) 15분마다 대기 중이 프로세스의 우선순위를 1씩 증가

## 2.4 라운드 로빈 스케줄링
> 특별히 시분한 시스템을 위해 설계됨

### 특징
준비 큐를 순환 큐로 설계하여, 준비 큐를 돌려가면서 
한 번에 한 프로세스에게 정의된 규정 시간량(시간 할당량) 만큼 프로세서를 제공한다.

새로운 프로세스를 추가할 때는 준비 큐의 맨 뒤에 붙인다.

준비 큐의 앞부분에 있는 프로세스에 프로세서를 할당한다.
1. 규정 시간 안에 작업을 마친 경우   
준비 큐의 다음 프로세스를 실행한다.
2. 프로세스의 실행 시간이 규정 시간량보다 긴 경우   
운영체제가 인터럽트하며, 중단된 프로세스의 레지스터들은 
프로세스의 프로세스 제어 블록에 저장하고, 프로세스는 준비 큐의 마지막 위치에 입력된다.
준비 큐의 다음 프로세스를 실행한다.

### 규정 시간량
프로세스 n개, 규정 시간량이 q시간 일때,
다음 규정 시간량을 할당 받을 때까지 (n-1) * q 시간 이상을 대기하지 않는다.
> 최대로 q시간 단위로 프로세서 시간의 1/n을 얻는다?

즉, 라운드 로빈 스케줄링의 성능은 규정 시간량의 크기에 큰 영향을 받는다
- 규정 시간량이 매우 크면 선입선처리 방법으로 변한다.
- 규정 시간량이 매우 작으면 프로세서 공유라고 하며, 
이론적으로 마치 n개의 프로세스가 실제 프로세서 속도의 1/n 속도로 
실행하는 것처럼 보인다.

대화식 프로세스는 규정 시간량보다 짧은 시간을 요청한다.
규정 시간량이 입출력까지의 계산 시간보다 커야 입출력 활용도를 극대화하고,
대화식 프로세스에 비교적 빠르게 반응할 수 있다.

### 최적 규정 시간량
#### 대화식 프로세스 관점   
#### 소프트웨어 관점규정   
규정 시간량이 너무 작은 경우 문맥 교환을 증가로 오버헤드 발생 및 반환시간 증가

### 장점
### 단점

## 2.5 다단계 큐 스케쥴링
> 각 작업을 서로 다른 묶음으로 분류할 수 있을 때 사용한다.   
> ex) 전면 작업과 후면 작업으로 분류 했을 때,
> 두 유형의 요청 반응시간이 다르고, 우선순위의 차이가 있을 때
> 서로 다른 스케줄링을 할 수 있다.

### 특징
- 준비 큐를 종류별로 여러 단계로 분할한다.   
- 작업을 메모리의 크기나 프로세스의 형태에 따라 특정 큐에 지정한다.   
- 각 큐는 독자적인 스케쥴리을 갖는다.
- 각 큐사이도 스케쥴링을 한다.
> ex) 전면 작업 큐는 라운드 로빈 스케쥴링, 
> 후면 작업 큐는 선입선처리 스케줄링 
> 큐 사이는 선점 수선순위 스케줄링
- 우선순위가 낮은 큐는 우선순위가 높은 큐가 모두 비어야 프로세서를 할당할 수 있다.
- 큐 사이에 시간을 나눠 사용할 수 있다. 
프로세서 시간의 일정량을 받아서 큐에 있는 프로세스들을 스케줄링할 수 있다.
> ex) 전면 작업 큐는 플세서 시간의 80% 할당, 후면 작업 큐는 프로세서 시간의 20% 할당

- 작업이 시스템에 들어가면 한 큐에서만 고정되어 실행한다.
작업은 한 큐에서 다른 큐로 옮기지 않기 때문에 스케줄링 부담이 적지만,
우선순위가 낮은 큐의 경우 무한정대기, 기아 상태 발생 가능

### 장점
### 단점

## 2.6 다단계 피드백 큐 스케줄링
### 특징
- 작업이 큐 사이를 이동할 수 있다.
- 프로세서 버스트의 특성에 따라 
프로세서 중심 프로세스는 낮은 우선순위 큐,
입출력 중심 프로세스는 높은 우선순위 큐에 놓는다.
- 기본적인 동작 방식은 다단계 큐 스케줄링과 동일하다.
- 단, 낮은 우선순위의 큐에 있는 프로세스를 우선순위가 높은 큐로 이동시키거나,
점유 시간이 긴 작업을 우선순위가 낮은 큐로 이동시켜 기아 상태를 예방할 수 있다. (에이징 방법)

일반적으로
- 우선순위가 낮은 큐일수록 규정 시간량이 크다.
즉, 어떤 프로세스가 해당 큐의 규정 시간량 안에 완료되지 않았을 경우,
한 단계 낮은 큐의 가장 뒤에 추가한다. 
이는 해당 프로세스의 규정 시간량을 증가시켜 프로세스가 더 오래 작업할 수 있도록 한다.
- 우선순위가 가장 낮은 큐의 경우 규정 시간량을 무한으로 하여 FCFS 방법으로 처리한다.

### 피드백 큐 스케줄링 정의 기준
- 큐 수
- 각 큐에 대한 스케줄링
- 작업을 좀 더 높은 우선순위의 큐로 격상 시키는 시기를 결정하는 방법
- 작업을 좀 더 낮은 우선순위의 큐로 격하 시키는 시기를 결정하는 방법
- 프로세스들이 어느 큐에 들어갈 것인지 결정하는 방법
- 프로세스가 서비스를 받는 시기를 결정하는 방법

### 장점
### 단점

## 2.7 HRN 스케줄링 - 비선점
> 최소작업 우선 스케줄링의 긴 작업과 잛은 작업 간의 지나친 불평등을 보완한 스케줄링

### 특징
- 비선점, 우선순위

- 우선순위 식
```
우선순위 = (서비스를 받을 시간 + 대기한 시간) / 서비스를 받을 시간
```
서비스를 받을 시간이 분모에 있으므로 > 시간이 짧은 작업일수록 우선순위가 높다.
'대기한 시간'이 분자에 있으므로 이 시간이 긴 작업일수록 우선순위가 높다

### 장점
### 단점

## 2.8 다중 프로세서 스케줄링
각 프로세서에는 독자적인 쿠와 독자적인 스케쥴링이 있으므로
프로세서가 다르면 가능한 선택의 경우 수가 상태적으로 제한된다.

하나의 시스템에 종류가 같은 프로세서가 여러 개이면 부하 공유가 발생한다.
이는 각 프로세서에 서로 독립된 준비 큐를 제공하도록 하여 방지할 수 있다.
이 방법은 프로세서를 모든 프로세스에 한 번만 할당하기 때문에
스케줄링 오버헤드가 적다는 장점이 있다. 
하지만, 어떤 프로세서는 큐가 비어 아무 일도 하지 않는 반면에,
다른 프로세서는 처리할 작업이 준비 큐에 가득 차 매우 바쁠 수 있다는 단점이 있다.

이러한 현상을 방지하려면 공동의 준비 큐를 사용하여 모든 작업이 이용 가능한 프로세서 큐로 가도록 스케줄링 해야한다.
그러면 프로세스가 메모리에 적재되는 동안 다른 프로세서에서 작업을 실행할 수 있다.
강결합된 공유 메모리 구조에서 모든 프로세서는 모든 프로세스에 대한 문맥 정보를 
이요할 수 있다는 장점이 있다.
따라서 프로세스의 스케줄링 비용은 프로세스가 스케줄링되는 프로세서에 독립적이다.

1. 프로세서 자신이 스스로 스케줄링한다.
각 프로세서는 공통의 준비 상태 큐에서 실행할 프로세스 하나를 선택한다.
- 프로세서 2개가 같은 프로세스를 선택하지 않도록 해야 하고,
- 프로세스가 큐에서 누락되지 않도록 해야 한다.
- 단일 프로세서 스케줄링 방법을 활용할 수 있으나, 
오히려 스케줄링이 복잡하여 오버헤드를 증가 시킬 수 있따.

2. 비대칭 다중 처리
한 프로세서를 다른 모든 프로세서의 스케줄러로 지정하고, 주종 구조를 보인다.
이 구조에서 운영체제의 핵심 커널 기능들은 특정 프로세서에서 수행하고,
다른 프로세서들은 사용자 프로세스만 수행한다.
주 프로세서는 프로세스들을 스케줄링하여 프로세스를 활성화시킨다.
종 프로세스에 입출력 호출 등의 서비스가 필요하면
주 프로세서에 요청하여 서비스의 처리를 기다린다.
이런 방법은 앞서 다룬 단일 프로세서 당중 프로그래밍 방법과 비슷하며,
자원 충돌 문제는 주 프로세서가 메인 메모리와 입출력 자원들을 제어하기 때문에
간단하게 해결할 수 있다. 그러나 주 프로세서의 오류는 시스템 전체를 정지시키며,
주 프로세서의 과중한 오버헤드는 성능의 병목 지점이 될 수 있는 문제점이 있다.

## 2.9 스레드 스케줄링
스레드 문맥 교화은 프로세스 문맥 교환보다 오버헤드가 적게 드므로
응용 프로그램 하나의 여러 스레드를 동시에 다른 프로세서에서 실행한다면
성능을 현저하게 향상시킬 수 있다.
그러나 스레드 간에 많은 상호작용을 요청하는 응용 프로그램에서는 
성능에 큰 영향을 줄 수 있다.

### 부하 공유
프로세서를 특정 프로세스 하나에 할당하지 않고 전역 큐에서 프로세서를 유지한다.
그리고 쉬고 있는 프로세스는 전역 큐에서 스레드 한 개를 선택한다.
단일 프로세서 환경에서 사용한 방법을 그대로 채택한 가장 단순한 방법이다.

#### 장점
#### 단점

### 갱 스케줄링
관련된 스레드의 집합을 일대일 대응 원칙에 따라 
프로세서 집합에서 동시에 실행할 수 있도록 스케줄링 하는 방법이다.
단일 프로세스에 속한 스레드들을 동시에 스케줄링한다.
응용 프로그램의 어떤 부분을 실행 준비한 동안에 다른 부분은
실행하지 못할 때 성능이 심각하게 떨어지는 응용 프로그램에 사용한다.

스레드 한 개를 실행하다가 같은 프로세스의 다른 스레드와 동기화해야 한다고 가정,
프로세스의 다른 스레드가 실행되지 않고 준비 큐에 있다면, 첫번째 스레드는 
다른 스레드가 다른 프로세서에서 실행될 수 있도록 프로세스를 교환할 때까지
실행을 지연한다. 따라서 밀접하게 관련된 프로세스들이 병렬로 실행된다면 동기화 대기 및 프로세스
문맥 교환의 횟수를 최소화하여 성능을 향상시킬 수 있다. 또 한번의 스케줄링 결정이
다수의 프로세서에 영향을 주기 때문에 스케줄링 오버헤드를 줄일 수 있다.

### 전용 프로세서 할당
스레드들을 실행 전담 프로세서에 할당하여 정의된 스케줄링을 제공하는 방법이다.
각 프로그램은 실행되는 동안 프로그램의 스레드 수와 동일한 수의 프로세스를 할당받기 때문에
프로세스가 낭비될 수 있다.
한 응용 프로그램의 스레드를 다른 스레드의 동기화나 입출력 대기 때문에 보류한다면
그 스레드의 프로세서는 계속 쉬게 되어 프로세서들의 다중 프로그래밍이 어렵다.
따라서 활성화된 스레드 수를 시스템의 프로세서와 동일한 수로 제한하여 효율성을
높이는 등 프로셋의 합리적인 이용을 지원해야 한다.

### 동적 스케줄링
프로그램의 스레드 수는 실행 도중 변할 수 있다. 동적 스케줄링은 프로세스의
스레드 수를 동적으로 변경하여 운영체제가 시스템 이용률을 높일 수 있도록 
부하 조절을 허용한 방법이다.
운영체제는 작업 간에 프로세서들을 분할하는 역할을 하여 각 작업을 스레드들에 
매핑시켜 프로세스에 할당된 프로세서들을 사용한다.
실행 중인 프로세스를 선점할 때, 어느 스레드를 일시중지할 것인지는
각 응용 프로그램의 실행 라이브러리 루틴들이 결정한다.
물론 이 과정이 모든 응용 프로그램에 적합하지 않을 수 있지만,
어떤 응용 프로그램은 운영체제의 이런 특별한 장점을 이용할 수 있다.

갱 스케줄링과 전용 프로세서 할당은 프로세서 단편화 문제를 회피하는 방법이다.
전용 프로세서 할당은 갱 스케줄링과 같이 프로세서를 효울적으로 할당하여
스케줄링 문제를 해결 한다.
즉, 주어진 시간에 얼마큼 프로세서를 하나의 프로세스에 할당하느냐가 관심사이다.
이는 프로세스의 스케줄링 문제보다는 메모리 할당과 비슷하여 주어진 시간에 
몇 개의 페이지 프레임을 프로세서에 할당할 것인가 하는 문제와 비슷하다.

# 3 스케줄링 알고리즘의 평가
## 3.1 스케줄링 알고리즘 평가 기준
1. 최대 응답시간이 1초라는 제약 조건에서 프로세서 이용률
2. 평균 반환시간이 전체 실행 시간에 선형적으로 비례하는 처리율
