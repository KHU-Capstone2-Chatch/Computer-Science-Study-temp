# 대칭키
어떤 메세지를 어떤 키를 이용해서 암호화를 하고 
암화화한 것을 상대에게 보냈다면
상대가 해당 키로 복호화 하면 내용을 볼 수 있다.
전송 당시 전송 내용과 키를 함께 전송해야하므로

만약 중간 메세지 탈취 o, key 탈취 x -> 암호화 o, 위/변조 x 및 인증 o
만약 중간 메세지 탈취 o, key 탈취 o -> 암호화 x, 위/변조 o 및 인증 x

ex) DES algorithm

# 공개키 - 개인키   
- 개인키로 암호화하면 공개키로 복호화
만약 중간 메세지 탈취 o -> 암호화 x(비밀성 x), 위/변조 x 및 인증 o

ex) SHA algorithm
ex) 은행
개인키로 암호화, 공개키도 다시 암호화(계층적으로 암호화)

- 공개키로 암호화하면 개인키로 복호화
만약 중간 메세지 탈취 o -> 암호화 o(비밀성 o), 위/변조 o 및 인증 x

----

# 암호의 개념
## 보안 공격과 보안 서비스
### 보안 공격
- 수동적 공격 : 훔처보기, 도청
- 능동적 공격 : 변조, 삽입, 삭제

### 보안 서비스
- 기밀성 : 정당한 사용자 만이 데이터의 내용을 파악할 수 있게 함
- 무결성 : 수신된 메시지에 불법적인 삽입이나 변조가 있는지 확인할 수 있게 함

ex) 전자 서명, 전자상거래...

## 암호의 개념 및 역사
- 암호화
- 복호화
- 암호 해독

### 수동 암호
- 치환 암호
- 전치 암호
- 다중문자 치환

### 기계 암호
- enigma 암호
- hagelin 암호

## 현대 암호 기술
- 대칭키 : 암호화와 복호화에 동일한 키 사용

- 비대칭키 : 공개키 암호 시스템
    - 송신자는 수신자의 공개키로 암호화
    - 수신자는 자신의 개인키로 복호화

### Feistel 암호
- 최초의 암호 시스템

특징
- 기본대치 맟 순열치환을 연속적으로 수행
- 짝수 라운드 적용
- 암/복호화 과정이 같음

# 대칭키 암호 시스템
## 데이터 암호화 표준 (DES : Data Encryption Standard)
- 56 비트 키
- 64 비트 블록 단위
- 16번의 동일한 complex 수행 
- 취약점 : 56 비트 키에 대한 안전성 문제 제기

## 진보된 암호화 표준(AES : Advanced Encryption Standard)
- 적어도 128비트 블록 단위
- 키 범위 : 128, 192, 256비트

## 삼중 DES
- 64비트 블록 단위의 대칭키 암호방식 중 가장 안전
- 64비트 키
- DES 3번 수행

## SEED : 블록 암호 알고리즘
- 한국정보보호진흥원에서 개발
- 16 라운드 Feistel 네트워크 
- 128 비트 블록 단위
- 128 비트 키
    
> 블록 암호 알고리즘 : 특정 비트 수의 집합을 한번에 처리하는 암호 알고리즘
> - DES, 3중 DES : 64 비트
> - AES : 128 비트

> 블록 암호 모드 : 긴 평문을 암호화하기 위해서 블록 암호 알고리즘을 반복해서 사용하는 방법
> - ECB
> - CBC
> - etc... 

# 공개키 암호 시스템
## 대칭키 암호 시스템 특징
- 암호키 분배 : 송시자와 수신자는 안전한 채널을 통해서 암호 키가 먼저 교환되어야 함
- 암호키 관리 : N 명의 상호통신을 위하여 요구되는 암호 키의 개수가 많이 요구됨

## 공개키 암호 시스템
- 네트워크에 공개되어 있는 공개키
- 비밀리에 보관하고 있는 개인키

- 암호키를 분배할 필요 없이 자신이 가지고 있는 개인키로 암호 복호화 가능
- N 명의 암호 통신을 위하여 요구되는 암호키의 개수는 2N

## 공개키 기법
- RSA
- Diffie-Hellman

### RSA(Rivest Sharmir Adleman) 암호 시스템
- 비밀로 유지하는 값 : 비밀키, 두 개의 소수 p, q
- 공개되는 값 : 공개키, N

- N과 서버의 공개키 정보를 획득하더라도, 
N 에서 p와 q를 분해하기 어려움, 서버의 개인키를 생성하는 것이 상당히 어려움
- RSA 암호 시스템의 안전성을 보장하기 위해 적어도 1024비트 길이이 N값 사용

### Diffie-Hellman의 키 교환
- 공개키를 교환하여 상호간에 사용할 비밀키 생성
- 비밀키는 암호문의 생성 및 평문의 복구를 위한 암호 및 복호키로 사용
> 두 사용자는 동일한 공개키와 비밀키를 사용한다.

- 전역 변수
    - P
    - r : p의 원시근
- 비밀 정수 
    - A, B : 각각의 사용자가 선택

> 각 사용자는 전역변수와 자신이 선택한 비밀정수를 사용하여 
> 비밀키를 생성하는데, 두 비밀키가 동일 하다. (수학적 기법)
> 마치 대칭키와 같은 효과가 있다.

대칭키 시스템은 개인키를 안전하게 교환했다는 가정하에 이루어지는데,
Diffie-Hellman 통해 교환 과정에서 개인키 기밀성, 무결성 문제를 해결 가능

- 취약점 : 공격자는 공개키를 변조할 수 있는 위험이 있음

#### 인증된 Diffie-Hellman의 키 교환 : 인증 작업
정말 그 공개키가 송신자로부터 온 것이 맞을까?

1. 송신자 : 공개키에 전자 서명을 한 후 전송
2. 수신자 : 받은 공개키에서 전자 서명 검증 작업 수행

## 정리
- 대칭키 암호 시스템
    - 기본 연산을 주로 사용, 계산 시간이 빠름 > 고속의 처리를 요구하는 IP 프로토콜에서 사용
- 공개키 암호 시스템
    - 대칭키 암호 시스템의 단점이 암호키의 관리와 분배 문제 해결
    - 큰 정수와 연관된 멱승 연산이 포함되어 계산 시간이 많이 걸림 > 전자상거래 및 인터넷 뱅킹에서 사용

# 해쉬 함수와 메시지 인증 코드
## 해쉬 함수
### 개요
- 결과값의 길이가 일정
- 해쉬함수(메세지를 분할한 일정한 길이의 블록) = 메시지 다이제스트 : 짧고 일정한 길이의 메시지 다이제스트 생성
- 메세지 다이제스트는 인증 알고리즘과 결합되어 전자서명 등에 사용되는 메시지 인증코드 생성
- ex) 해쉬 함수 : MD5, SHA-1, RIPEMD-160, HAS-160

### 요구사항
- 일방향성 : 역변환 어렵, 메시지 다이제스트로부터 원래의 메시지에 대한 계산 불가능
- 어떤 크기의 데이터 블록이든지 적용 가능해야함
- 강한 충돌 회피성
    - 다른 두 개의 메시지에 대하여 해쉬 함수를 적용한 결과 항상 다른 메시지 다이제스트를 출력

## 메시지 인증코드
### 개요
해쉬함수를 이용해 만든 메시지 다이제스트를
인증 알고리즘과 암호 키를 적용하여 메시지 인증코드로 만든다.

- 응용
    - 신원 확인
    - 무결성 서비스 : 변조 x
    - 부인 방지 : 부인 번복 x

### 대칭키 암호 기반의 메시지 인증
- 송신자
    1. 메세지 전송
    2. 보낸 메세지 > 해쉬함수 > 메시지 다이제스트 > 암호 알고리즘(대칭키) > 메시지 인증 코드

- 수신자
    1. 받은 메세지 > 해쉬함수 > 매시지 다이제스트
    2. 복호 알고리즘(대칭키) > 메시지 다이제스트

3번과 4번의 결과 메시지 다이제스트가 일치하면 인증 성공
> 대칭키이기 때문에 안전하게 대칭키를 공유했다고 가정

### 공개키 암호 기반의 메시지 인증 : 해쉬 함수 O
- 송신자
    1. 메세지 전송
    2. 보낸 메세지 > 해쉬함수 > 메시지 다이제스트 > 암호 알고리즘(개인키) > 메시지 인증 코드

- 수신자
    1. 받은 메세지 > 해쉬함수 > 매시지 다이제스트
    2. 복호 알고리즘(공개키) > 메시지 다이제스트

3번과 4번의 결과 메시지 다이제스트가 일치하면 인증 성공

### 공개키 암호 기반의 메시지 인증 : 해쉬 함수 X
- 송신자 : 메시지를 작성 후 개인키로 메시지 전체를 암호화
- 수신자 : 공개키로 암호문 복호화

해독할 수 있는 평문을 얻으면 메세지 인증

> 해쉬 함수 없는 메세지 인증
> - 메시지 전체에 대하여 메시지 인증코드의 생성 및 검증을 수행하므로 시간 많이 소요
> - 별도의 해쉬 함수 필요 없음
>
> 해쉬함수 기반 메시지 인증
> - 메시지 인증코드의 추가 전송으로 전송량 증가
> - 메시지 인증코드의 생성 및 검증이 빠름

### 공유 비밀키 기반의 메시지 인증
1. 송신자와 수신자는 사전에 공유된 비밀키 공유 > Diffie-Hellman 활용
2. 송신자는 비밀키를 메시지에 추가하여 해쉬 함수 수행 : H(비밀키 + 메시지) = 메시지 다이제스트
3. 비밀키를 제외한 메시지와 생성된 메시지 다이제스트를 동시에 전송 : 메시지 + 메시지 다이제스트
4. 수신자는 메시지에 비밀키를 추가하여 해쉬함수 수행
5. 3번의 메시지 다이제스트와 4번의 결과 메시지 다이제스트가 동일하면 메시지 인증

#### HMAC
- 공유 비밀키 기반의 메시지 알고리즘
- 안전성 : 
사용되는 해쉬 함수가 강한 충돌 회피성을 갖고 있는 경우 안전성 보장

# 공개키 기반구조
## 공개키 방식 메시지 인증의 취약성
1. 위조된 공개키 배포
2. 위조된 개인키로 전자서명 생성하여 전송

위조된 공개키로 수신한 문서를 인증하면 공개키와 개인키가 
모두 위조되어있기 때문에 문서의 위조 사실을 확인할 수 없다.

## 공개키 방식에서 인증서의 필요성
- 공개키의 위조를 방지하기 위하여 
자신의 공개키 및 개인 정보를 인증기관에 인증서로 등록
- 공개키를 가져오기 위해 인증서를 인증 기관에 요청

## 공개키 기반 구조
### 필요성
- 공개키 암호 시스템의 광범위한 응용으로 공개키를 관리하고 분배하는 구조 필요
- 공개키를 관리하고 분배하는 구조 - PKI(public-key infra-structure) :
공개키의 생성, 관리, 저장, 분배, 폐지등에 필요한 하드웨어, 소프트웨어, 인력, 정책 및 절차

### 구성요소
- 사용자 : 인증서를 발행받아 전자상거래나 인터넷 뱅킹 등을 사용
- 등록기관 : 인증서 신청자의 신원 확인 및 인증서 등록을 대행하는 기관
- 인증기관 : 인증서 발생하는 기관
- 저장소 : 인증서를 인증서의 취소목록을 저장하는 장소

### 인증서
- 공신력 있는 인증기관이 발행한 사이버 거래의 인감증명서
- 위조가 불가능하도록 실체의 정보와 공개키 그리고 인증기과의 정보가 수록된 
인증서를 인증기관의 개인키로 서명하여 발급
- ex) X.509, PGP

그 인증서가 진짜라는 것을 어떻게 증명??

### 인증기관(CA: Certificate Authority)
인증서의 생성, 배정, 관리 등의 작업을 수행하는 기관

- 민간분야 NPKI : KISA
- 정부분야 GPKI

#### 키 생성 및 관리 : 사용자 키 생성 방식
1. 토큰 생성 : 인증기관에서 사용자의 신분확인, 토큰에는 사용자가 자신의 공개키/개인키 쌍을 생성할 수 있는 정보 포함
2. 토큰을 안전한 채널로 사용자에게 전송
3. 키 생성 : 공개키 개인키 생성
4. 인증서-생성 요청 : 사용자가 인증기관에 공개키를 포함하고 있는 인증서-생성 요청 메시지 전송
5. 인증서-생성 응답 : 인증서-생성 요청 메시지의 유효성을 확인 후, 응답 메시지 사용자에게 전송
6. 인증서 저장 : 발급한 인증서를 인증서 보관소에 저장

#### 키 생성 및 관리 : 중앙 집중형 키 생성 방식
1. 토큰 생성 : 인증기관에서 사용자의 신원확인 후 토큰 생성, 토큰에는 인증기관이 생성한 사용자의 공개키/개인키 쌍과 인증서 포함
2. 토큰을 안전한 채널로 사용자에게 전송
3. 인증서 저장 : 인증기관에서 발급한 인증서를 인증서 보관소에 저장
4. 사용자는 토큰에 있는 인증서와 공개키/개인키 사용

### X.509 표준 권고안
- 이렉터리 서비스의 인증 지원
    - 인증서의 분배와 관련된 데이터 형식과 절차 정의
    - 인증서 폐지목록 메커니즘 정의

#### IETF 의 PKIX (public-key infrastructure X.509) 작업반
X.509 기반의 PKI를 지원하기 위한 인터넷 표준 개발을 위하여 구성
- 프로파일 정의
- 운영 프로토콜
- 관리 프로토콜

#### X.509 인증서 형식
- 발급자 : 인증기관(CA)의 고유명
- 유효기간 : 인증서의 개시 및 만료일자
- 주체의 공개키 : 공개키 및 사용할 암호 알고리즘
- 발급자의 서명 : 서명 값 필드를 제외한 모든 필드에 CA의 개인키(비밀키)와 서명 알고리즘을 적용하여 생성

> 잊지 말아야 할것은 이 인증서는 인증서에 작성된 공개키가 맞는 공개키라는 것을 인증 받기 위한 것이다.

### X.509 인증서의 상태 검사
- 인증서 폐지 목록
- 온라인 인증서 상태확인 프로토콜

#### 인증서 폐지 목록(CRL)
- 일정한 시간 간격으로 CRL 발행
- 폐지된 인증서의 상태를 실시간으로 알 수 없음

#### 온라인 인증서 상태확인 프로토콜(OCSP)
특정 인증서의 유효성을 온라인으로 언제든지 확인할 수 있는 매커니즘 제공

### X.509 신뢰 모델
- 인증서의 유효성을 결정하기 위해 사용하는 규칙
- 계층적 신뢰를 사용
- 최상위 인증기관인 A는 자체 서명한 인증서를 발행
- 최종 사용자 및 중간 인증기관의 인증서는 상위의 인증기관이 발급

#### 인증서의 검증 절차
최상위 인증서가 아니면 인증서 발급자의 인증서를 구하여 검증 절차 재수행

#### 최상위 인증기관
최상위 인증기관의 개인키는 엄격한 보안이 요구
- 최소한 160비트 메시지 다이제스트를 갖는 해쉬함수 사용
- 개인키의 길이는 최소한 2048 비트 사용

# 인터넷 보안 프로토콜 (IPSec)
## IPSec
> 과거에는 보안이 중요한 고려 대상이 아니었기에 보안이 취약했음

- IP 보안 : 키관리(ISAKMP), 인증헤더(AH), 캡슐화 보안 페이로드(ESP) 및 압축 프로토콜
- SSL : 웹 서버와 브라우저 사이의 안전한 통신을 위해 개발됨, 서버/클라이언트 인증, 기밀성 보장
- TLS : SSL 을 기반으로 표준화

### 인터넷 보안 프로토콜의 구조
- ISAKMP : Internet Security Association Key Management Protocol
- SA : Security Association
- SAD: Security Association Database
- SPD: Security Policy Database

### IP 보안 프로토콜의 서비스
- 인증코드를 이용한 IP 패킷의 무결성과 인증 기능
- 암호화를 통한 IP 패킷의 기밀성 제공
- 재전송되어 수신된 IP 패킷의 감지 및 폐기

네트워크 계층에 제공되므로 전송계층 및 모든 응용 서비스들이 IP 보안 프로토콜의 보안 서비스 사용

### IP 보안 프로토콜의 개요
- 키 관리 프로토콜 (ISAKMP) : 인증과 암호화에 필요한 알고리즘 선택 및 키의 생성과 분배 
- 인증 헤더(AH) 및 캡슐화 보안 페이로드(ESP) 프로토콜 : 
    - 인증 헤더 프로토콜 : 패킷의 근원에 대한 인증과 전송 중에 변조되지 않았음을 보장하는 무결성 서비스 제공
    - 캡슐화 보안페이로드 프로토콜 : IP 패킷으리 기밀성 제공을 위한 암호화 기능과 무결성 및 인증 기능 제공
    - 보안 알고리즘
        - 인증 및 무결성 서비스 : HMAC-MD5, HMAC-SHA-1
        - 기밀성 서비스 : 3DES-CBC, AES-CBC

- IP 압축 프로토콜 : IP 보안 프로토콜의 사용으로 증가되는 IP 패킷의 길이를 감소시켜 대역폭 사용의 효율성을 높임

### 보안 연계(SA : Security Association)
IP 보안 프로토콜, 프로토콜의 운용
모드, 보안 알고리즘, 보안 키와 키의 수명 등에 대한 통신 쌍방 간의 합의
- 키 관리 프로토콜(ISAKMP) (ISAKMP)은 보안연계의 설정 및 해제 기능 담당
- 각 호스트는 송신과 수신 트래픽을 위하여 별도의 보안연계 설정
- 보안연계의 종류: 
    - 인증헤더(AH) 보안연계
    - 캡슐화 보안 페이로드(ESP) 보안연계
    - 압축(IPComp) 보안연계

#### 보안 연계 운영 모드
- 트랜스포트 모드
    - 호스트와 호스트 간의 보안 연계
    - 원래 IP 헤더의 발신지 및 목적지 주소를 그대로 유지
- 터널 모드
    - 보안 게이트웨이와 보안 게이트웨이 사이 or  호스트와 보안 게이트웨이 사이
    - 보안 게이트웨이에서 IPSec 프로토콜 구현
    -  새로운 IP 헤더를 만들어 원래의 IP 패킷을 모두 페이로드화

### 보안 데이터베이스
- 보안 정책 데이터베이스(SPD) :
    - IP 패킷의 선택자 정보를 이용하여 IP 패킷에 IPSec 적용 여부 판단
    - 패킷에 IPSec 을 적용하는 경우 보안 연계 데이터베이스의 관련 항목 지정
- 보안 연계 데이터베이스(SAD) :
보안 연계와 관련된 암호 및 인증 알고리즘과 키 값 등의 매개변수 저장

#### SPD
- IPSec 적용 여부를 결정하기 위해 하나 이상의 선택자 정보를 이용
    - 발신지 및 목저지 IP 주소
    - 전송 계층 프로토콜 종류
    - etc...
- 지시자 : 선택자들과 일치하는 IP 패킷의 폐기, 통과 또는 IPSec 처리를 지시
- IPSec 처리가 요구되는 경우 보안 연계 데이터베이스의 관련 항목을 지정

#### SPA
각 항목에 IPSec 에 적용할 보안 연계를 나타냄
- 인증 알고리즘, 인증 키
- 암호 알고리즘, 인증 키
- IPSec 프로토콜 동작모드, 식별자
- etc..

### IP 보안 프로토콜의 송신 및 수신 처리
`그림`

## 인증헤더 프로토콜 (AH)
### 개요
- IP 헤더 및 패킷 내용의 변조 여부를 확인할 수 있는 무결성 서비스
- 데이터의 근원지를 식별하는 인증 서비스
- 공격자에 의한 재전송 패킷의 감지

인증헤더 프로토콜은 IP 버전 4의 보안 취약성을 개선하기 위하여 메시지 인증코드
사용
> 과거 보안을 중시하지 않아 전체 헤더 합을 검사하는 방식을 사용함, 이 경우
> 공격자가 IP 헤더의 필드(예, 송신지 IP 주소)를 변경 후 쉽게 
> 헤더 검사합을 다시 계산하여 수신자에게 전송시 수신자는 위/변조 사실을 알 수 없다.

### 메시지 형식
- 보안 파라미터 인덱스 : 목적지 IP 주소와 함께 보안 연게 데이터베이스의 보안 연계를 구분하는 인덱스
- 순서 번호 : 공격자에 의한 재전송 패킷 감지
- 인증 데이터 : 
    - 무결성 검사 값(ICV)을 포함
    - ICP 의 생성에 이용되는 알고리즘은 보안 연계에 정의
    - 메세지 인증 알고리즘
        - ex) HMAC-MD5, HMAC-SHA-1, AES-XCBC-MAC

### 인증 데이터의 새성 및 검증 과정
1. 송신자는 인증키를 메시지에 추가하여 HMAC 알고리즘의 수행 결과로 생성된 무결성 검사값을 AH 헤더의 ICV 필드에 세팅
2. 생성된 AH 를 포함하는 메시지 전송
3. 수신자는 수신된 메시지에 인증키를 추가하여 HMAC 알고리즘 수행 
4. 1번의 ICV 와 3번의 결과값이 일치하면 '송신자 메시지 인증 및 무결성 보장'

#### HMAC
1. 중간 메시지 인증코드 = 해쉬함수(인증키 + 메시지)
2. 해쉬함수(인증키 + 중간 메시지 인증코드) = 최종 메시지 인증코드

### IPV4 에서 인증헤더 위치
- 트랜스포트 모드 : IP 헤더 뒤
- 터널 모드 : 새로운 IP 헤더와 기존 IP 헤더 사이

### 인증 헤더 프로토콜의 송/수신 처리
- 보안 연계 추출 > 순서 번호 생성 > ICV 계산 > 분할 > 패킷 송신 > 인터넷
- 인터넷 > 패킷 수신 > 결합 > 보안 연계 추출 > 순서 번호 검증 > ICV 검증

## 캡슐화 보안 페이로드 프로토콜 (ESP)
### 개요
- 정당한 사용자 만이 패킷의 내용을 파악하도록 하는 기밀성 서비스
- 데이터의 근원지를 식별하는 인증 서비스
- IP 헤더 및 패킷 내용의 변조 여부를 확인할 수 있는 무결성 서비스
- 공격자에 의한 재전송 패킷의 감지 및 폐기

기밀성 서비스를 위하여 암호화에 대칭키 암호 알고리즘 사용

### 보안 알고리즘
- 상호 운용성을 보장하기 위해 규정한 필수구현 암호화 알고리즘
    - NULL 암호화 알고리즘: 암호화를 수행하지 않음을 의미
    - 데이터 암호화 표준(DES)
    - 3 중 DES(3DES-CBC)
    - 128 비트 암호키의 진보된 암호화 표준(AES-CBC)
- 인증 및 무결성 서비스를 위하여 규정한 필수구현 인증 알고리즘
    - NULL 인증 알고리즘: 인증을 수행하지 않음을 의미
    - HMAC-MD5 
    - HMAC-SHA-1 
    - AES-XCBC-MAC

### 메시지 형식
- ESP 헤더
    - 보안 파라미터 인덱스 : 목적지 IP 주소와 함께 보안연계 데이터베이터베이스의 보안 연계를 구분하는 인덱스
    - 순서 번호 : 공격자에 의한 재전송 패킷 감지
- ESP 트레일러
    - 패딩 : 암호화 알고리즘이 블록 단위의 평문을 요구하는 경우 페이로드 데이터를 블록 길이의 배수가 되도록 확장하기 위해 사용
    - 다음 헤더 : 페이로드 데이터 필드에 포함되어 있는 데이터의 유형을 식별하는 필드 (전송계층 프로토콜 TCP or UDP)
- 인증 데이터
    - 무결성 검사 값 포함
    - ESP 메시지 전체에서 인증 데이터 필드를 제외한 부분에 대해 무결성 검사 값 계산

### IPV4 에서 ESP 위치
ESP 적용 전

| IP 헤더 | TCP 헤더 | 데이터 |
|---|---|---|

ESP 적용 후 : 트랜스포트 모드

| IP 헤더 | ESP 헤더 | TCP 헤더 | 데이터 | ESP 트레일러 | ESP 인증 데이터 |
|---|---|---|---|---|----|

ESP 적용 후 : 터널모드

| 새로운 IP 헤더 | IP 헤더 | ESP 헤더 | TCP 헤더 | 데이터 | ESP 트레일러 | ESP 인증 데이터 |
|---|---|---|---|---|---|----|

암호화 영역 : ESP 헤더 다음 부터 ESP 트레일러 까지
인증 영역 : ESP 헤더부터 ESP 트레일러

> ESP 트랜스포트 모드와 터널 모드 비교   
> 터널 모드
> - 원래의 IP 패킷 부터 인증 및 암호화 하여 높은 보안성 제공
> - 새로운 IP 헤더가 삽입되므로 더 많은 대역폭 사용
> - 패킷의 원래 발신지 및 목적지 IP 주소가 있는 원래의 IP 헤더가 암호화되므로 트래픽 흐름의 기밀성 서비스 제공

### ESP 프로토콜의 처리
- 보안 연계 추출 > 순서 번호 생성 > 패킷 암호화 > ICV 계산 > 분할 > 패킷 송신 > 인터넷
- 인터넷 > 패킷 수신 > 보안 연계 추출 > 순서 번호 검증 > ICV 검증 > 패킷 복호화

## 인터넷 보안연계 키관리 프로토콜 (ISAKMP)
### ISAKMP 의 2 단계 협상
- 단계 1의 협상 : ISAKMP 보안 연계 수립
- 단계 2의 협상 : IP 보안 프로토콜(AH, ESP, IP 압축)의 보안 연계 수립

### ISAKCMP 헤더 메시지 형식
- 개시자/응답자 쿠키 :
    - 개시자 및 응답자에 의해 발생되는 고유 비트 열
    - 서비스 거부 공격에 대한 보호용으로 사용
    - 쿠키 발생 방식은 ISAKMP 의 구현에 따라 다름
- 다음 페이로드 : ISAKMP 메시지의 첫번째 페이로드 유형 식별
- 주 버전 : 자신보다 높은 주 버전이나 부 버전 값을 갖는 ISAKMP 메시지는 받아들이지 않음
- 부 버전
- 교환 유형 : 단계 1, 단계 2의 협상에서 교환되는 페이로드의 유형과 순서를 규정
- 플래그 : ISAKMP 메시지의 페이로드가 암호화 또는 인증되었음을 나타내는 플래그
- 메시지 식별자 : 단계 2의 협상에서 개시자가 발생시킨 난수 값으로 키 생성에 사용

### ISAKCMP 페이로드 형식
- 공통 헤더 :
    - 다음 페이로드 : 다음에 나타나는 페이로드의 유형을 표시
    - 예비
    - 페이로드 길이 : 현재 페이로드의 길이
- 페이로드 정보 : 페이로드 유형펼로 정의된 정보 포함

### 보안 연계 페이로드
보안연계의 설정 및 협상이 발생하는 도메인을 표시
- 인터넷에 적용되는 IP 보안 프로토콜 도메인은 한 예이며 ISAKMP는 다른 도메인에도 사용 될 수 있음

> 보안연계 페이로드와 제안 및 트랜스폼 페이로드의 관계
> - 하나의 보안연계 페이로드에 IP 보안 프로토콜을 나타내는 하나 이상의 제안 페이로드가 ISAKMP 메시지에 포함될 수 있음
> - 하나의 제안 페이로드에 보안 알고리즘을 나타내는 하나 이상의 트랜스폼 페이로드가 ISAKMP 메시지에 포함될 수 있

### 제안 페이로드
보안연계에 대하여 선호하는 보안 프로토콜과, 해당 보안 프로토콜에 관련된 트랜스폼
페이로드의 개수를 상대방에게 제안

### 기타 페이로드
- 트랜스폼 페이로드
- 키교환 페이로드 : 키 생성시 필요한 키교환 데이터 전달
- 신분 페이로드
- etc...

## 인터넷 키교환 프로토콜 (IKE)
### 개요
IKE는 오클리 및 SKEME 키교환 기술을 ISAKMP 프래임워크 내에서 구현한 합성 프로토콜
- IP 보안 프로토콜을 위한 보안연계 협상
- IP 보안 프로토콜 동배들로 하여금 암호 키와 인증 키를 생성시킬 수 있도록 키 생성 자료를 교환

> - IKE: Internet Key Exchange
> - ISAKMP: Internet Security Association and Key Management Protocol 
> - SKEME: Secure Key Exchange Mechanism for Internet

### 오클리 키교환 프로토콜
Diffie-Hellman의 장점을 유지하며, 취약성을 개선한 프로토콜
- Diffie-Hellman의 장점 : 보안키는 필요할 때만 생성하며, 
키의 교환은 전역 변수(p와 r)들의 합의 이외에는 특별한 요구사항이 없다.
- Diffie-Hellman Hellman의 취약성 : 송신 및 수신자의 신분정보를 제공하지 않으며, 
중간자 공격을 받기 쉽다.

# SSL/TLS 보안 프로토콜
- 보안 소켓 계층(SSL: secure socket layer) : 
    - 웹 서버와 브라우저 사이의 안전한 통신 > 사실상의 업계 표준
    - HTTP, SMTP, POP3 등의 프로토콜이 위에서 동작 가능
- 트랜스포트 계층 보안(TLS: Transport layer security)

## SSL/TLS 보안 서비스
- 기밀성
- 무결성
- 인증

- SSL/TLS 보안 구조
    - 핸드쉐이크 프로토콜
    - 암호사양변경 프로토콜
    - 경고 프로토콜
    - 레코드 프로토콜

### 핸드쉐이크와 암호사양변경 프로토콜
- 3 핸드 쉐이크 직후 이루어지는 SSL 핸드 쉐이크
- 1-3 단계 : 핸드쉐이크 프로토콜
    - 1단계 : 보안 능력 설정
    - 2단계 : 서버 인증 및 키 교환
    - 3단계 : 클라이언트 인증 및 키 교환
- 4단계 : 암호사양 변경 메시지 교환 및 핸드쉐이크 종료

#### 1 단계 : 보안 능력의 설정
(1) ClientHello(클라이언트 → 서버)

(2)ServerHello(클라이언트 ← 서버) 
- 사용할 수 있는 버전 번호, 현재 시각, 랜덤 값, 세션 ID 
- 사용할 수 있는 암호 스위트(cipher suite) 목록
    - 키 교환 방법: 
        - RSA: 사전마스터 비밀 값(premaster secret)이 수신자의 공개키로 암호화되어 전달
        - Fixed Diffie-Hellman: 인증된 공개키 파라미터 값 교환
        - Anonymous Diffie-Hellman: 인증 없이 공개키 파라미터 값 교환
    - 암호 명세(ChiperSpec): 암호 알고리즘(DES, 3DES, AES), 해쉬 알고리즘(SHA, MD5) 
- 사용할 수 있는 압축 방법

#### 2 단계 : 서버 인증 및 키 교환
(3) Certificate(클라이언트 ← 서버): 클라이언트가 수행하는 서버의 인증을 위하여 서버의 X.509 인증서를 전달
- 단계 1에서 설정된 키 교환 방법이 Fixed Diffie-Hellman 인 경우
: 인증기관에 의하여 서명된 인증서로 공개키 파라미터 값 교환

(4) ServerKeyExchange(클라이언트 ← 서버)
- 단계 1에서 설정된 암호 스위트의 키 교환 방식에 따라서 다음과 같은 키 값 교환
    - RSA: 암호화한 사전마스터 비밀 값
    - Anonymous Diffie-Hellman: 공개키 값

(5)CertificateRequest(클라이언트 ← 서버) 
- 클라이언트를 인증하기 위하여 클라이언트에게 인증서를 요청

(6)ServerHelloDone(클라이언트 ← 서버): 
- ServerHello 메시지부터 시작해서 지금까지 교환된 메시지의 끝을 나타낸다.

#### 3 단계 : 클라이언트 인증 및 키 교환
(7) Certificate(클라이언트 → 서버)
- 서버로부터 (5)CertificateRequest 메시지가 왔을 경우에 클라이언트의 인증서를 전달하는 메시지
- 단계 1에서 설정된 키 교환 방법이 Fixed Diffie Fixed Diffie- Hellman인 경우 
    - 인증서로 공개키 파라미터 값 교환

(8) ClientKeyExchange(클라이언트 → 서버)
- 단계 1에서 설정된 암호 스위트의 키 교환 방식에 따라서 다음과 같은 키 값 교환
    - RSA: 서버 인증서에 있는 공개키로 암호화한 사전마스터 비밀 값
    - Anonymous Diffie-Hellman Hellman: 공개키 값

(9) CertificateVerify(클라이언트 → 서버)
- 마스터 비밀키 값과 핸드쉐이크 메시지들의 결합에 대한 해쉬 함수 값(전자 서명)을 
서버에게 전달하므로 클라이언트가 전달한 인증서를 보장하게 된다.

#### 4 단계 : 암호사양 변경 및 핸드쉐이크 종료
(10) ChangeCipherSpec(클라이언트 → 서버) 
- 암호사양변경 프로토콜의 메시지를 교환하므로 이전 단계에서 협의된 암호 스위트의 적용을 개시한다. 

(11) Finished(클라이언트 → 서버)
- 핸드쉐이크의 종료를 통보하는 메시지

(12) ChangeCipherSpec(클라이언트 ← 서버) 
- 암호사양변경 프로토콜의 메시지를 교환하므로 이전 단계에서 협의된 암호 스위트의 적용을 개시한다. 

(13) Finished(클라이언트←서버) 
- 핸드쉐이크의 종료를 통보하는 메시지

#### 마스터 비밀값
1. RSA 또는 Diffie-Hellman 키 교환 
2. 사전마스터 비밀 값(premaster secret) 생성 
3. SHA-1과 MD5 해쉬함수를 이용한 48바이트의 마스터 비밀 값 (master secret)생성

### 경고 프로토콜
SSL/TLS 통신 중에 발생한 에러를 전달하는 프로토콜

### 레코드 프로토콜
서버와 클라이언트가 핸드쉐이크 프로토콜을 사용해서 결정한 알고리즘과 키 값을 이용하여 
대칭 암호화/복호화와 메시지 인증코드(MAC)를 생성한다.

### SSL 보안의 한계
- SSL은 점대점(point-to-point) 범위로 데이터를 보호할 수 있지만 
중간 웹 서버를 통해서 다시 전달(forwarding) 되는 데이터의 보호는 보장되지 않음 
> 응용 계층에서의 암호화를 통한 종단 범위의 암호화가 요구됨
- 전체 메시지를 암호화/복호화하는 오버헤드 문제
> XML(eXtensible XML(eXtensible Markup Language) Language)의 보안을 이용하여 필요한 정보만을 암호화