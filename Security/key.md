# 대칭키
어떤 메세지를 어떤 키를 이용해서 암호화를 하고 
암화화한 것을 상대에게 보냈다면
상대가 해당 키로 복호화 하면 내용을 볼 수 있다.
전송 당시 전송 내용과 키를 함께 전송해야하므로

만약 중간 메세지 탈취 o, key 탈취 x -> 암호화 o, 위/변조 x 및 인증 o
만약 중간 메세지 탈취 o, key 탈취 o -> 암호화 x, 위/변조 o 및 인증 x

ex) DES algorithm

# 공개키 - 개인키   
- 개인키로 암호화하면 공개키로 복호화
만약 중간 메세지 탈취 o -> 암호화 x(비밀성 x), 위/변조 x 및 인증 o

ex) SHA algorithm
ex) 은행
개인키로 암호화, 공개키도 다시 암호화(계층적으로 암호화)

- 공개키로 암호화하면 개인키로 복호화
만약 중간 메세지 탈취 o -> 암호화 o(비밀성 o), 위/변조 o 및 인증 x


보안 공격
- 수동적 공격 : 훔처보기, 도청
- 능동적 공격 : 변조, 삽입, 삭제

보안 서비스
- 기밀성 : 정당한 사용자 만이 데이터의 내용을 파악할 수 있게 함
- 무결성 : 수신된 메시지에 불법적인 삽입이나 변조가 있는지 확인할 수 있게 함

암호의 개년
- 암호화
- 복호화
- 암호 해독

수동 암호
- 치환암호
- 전치 암호

기계 암호

현대 암호
- 대칭키   
    - 암호화 키 == 복호화 키

- 비대칭키   
    - 공개키 암호 시스템
    - 암호화 키 != 복호화 키

Feistel 암호의 특정
    - 순열 치환을 연속적으로 수행
    - 짝수 라운드 적용
    - 암/복호화 과정이 같음

데이터 암호화 표준 (DES : Data Encryption Standard)
    - 64비트 블록 단위
    - 16번의 complex
    - 취약점 : 56 비트 키에 대한 안전성 문제 제기

진보된 암호화 표준(AES : Advanced Encryption Standard)
    - 128비트 블록 단위
    - 키 범위 : 128, 192, 256비트

삼중 DES
    - 64비트 블록 단위의 대칭키 암호방식 중 가장 안전
    - 64비트 키
    - DES 3번
    
블록 암호 알고리즘 : 특정 비트 수의 집합을 한번에 처리하는 암호 알고리즘
    - DES, 3중 DES : 64 비트
    - AES : 128 비트

블록 암호 모드 : 긴 평문을 암호화하기 위해서 블록 암호 알고리즘을 반복해서 사용하는 방법

SEED
    - 한국정보보호진흥원에서 개발
    - 16 라운드 Feistel 네트워크 
    - 128 비트 블록 단위
    - 128 비트 키
    
대칭키
- 암호키 분배 : 송시자와 수신자는 안전한 채널을 통해서 암호 키가 먼저 교환되어야 함
- 암호키 관리 : N 명의 상호통신을 위하여 요구되는 암호 키의 개수가 많이 요구됨

공개키
- 네트워크에 공개되어 있는 공개키
- 비밀리에 보관하고 있는 개인키
- N 명의 암호 통신을 위하여 요구되는 암호키의 개수는 2N

RSA(Rivest Sharmir Adleman) 암호 시스템

- 비밀로 유지하는 값 : 비밀키, 두 개의 소수 p, q
- 공개되는 값 : 공개키, N

- N과 서버의 공개키 정보를 획득하더라도, 
N 에서 p와 q를 분해하기 어려움, 서버의 개인키를 생성하는 것이 상당히 어려움
- RSA 암호 시스템의 안전성을 보장하기 위해 적어도 1024비트 길이이 N값 사용

Diffie-Hellman의 키 교환
- 공개키를 교환하여 상호간에 사용할 비밀키 생성
- 비밀키는 암호문의 생성 및 평문의 복구를 위한 암호 및 보호 키로 사용

전역 변수   
- P, r : p의 원시근
- 비밀 정수 A, B

대칭키에서 개인키를 교환하는 것에 문제가 있었다면,
위 방식을 통해 교환 과정에서 개인키 기밀성, 무결성 문제를 해결 가능

공격자는 공개키를 변조할 수 있는 위험이 있음

인증된 Diffie-Hellman의 키 교환
- 공개키에 전자 서명을 한 후 전송
- 받은 공개키에서 전자 서명 검증 작업 수행

정리
- 대칭키 암호 시스템
    - 기본 연산을 주로 사용, 계산 시간이 빠름 > 고속의 처리를 요구하는 IP 프로토콜에서 사용
- 공개키 암호 시스템
    - 대칭키 암호 시스템의 단점이 암호키의 관리와 분배 문제 해결
    - 큰 정수와 연관된 멱승 연산이 포함되어 계산 시간이 많이 걸림 > 전자상거래 및 인터넷 뱅킹에서 사용

전자 서명 어떻게 믿지??

해쉬 함수
- 일방향성 : 역변환 어렵, 메시지 다이제스트로부터 원래의 메시지에 대한 계산 불가능
- 결과값의 길이가 일정
- 어떤 크기의 데이터 블록이든지 적용 가능해야함
- 강한 충돌 회피성
    - 다른 두 개의 메시지에 대하여 해쉬 함수를 적용한 결과 항상 다른 메시지 다이제스트를 출력

메세지 > 해쉬함수 > 메시지 다이제스트 : 짧고 일정한 길이의 메시지 다이제스트 생성

- ex) 해쉬 함수 : MD5, SHA-1, RIPEMD-160, HAS-160

메시지 인증코드
- 신원 확인
- 무결성 서비스 : 변조 x
- 부인 방지 : 부인 번복 x

대칭키 암호 기반의 메시지 인증
1. 메세지 전송
2. 보낸 메세지 > 해쉬함수 > 메시지 다이제스트 > 암호 알고리즘(대칭키) > 메시지 인증 코드

3. 받은 메세지 > 해쉬함수 > 매시지 다이제스트
4. 복호 알고리즘(대칭키) > 메시지 다이제스트

3번과 4번의 결과 메시지 다이제스트가 일치하면 인증 성공
> 안전하게 대칭키를 공유했다고 가정

공개키 암호 기반의 메시지 인증
1. 메세지 전송
2. 보낸 메세지 > 해쉬함수 > 메시지 다이제스트 > 암호 알고리즘(개인키) > 메시지 인증 코드

3. 받은 메세지 > 해쉬함수 > 매시지 다이제스트
4. 복호 알고리즘(공개키) > 메시지 다이제스트

3번과 4번의 결과 메시지 다이제스트가 일치하면 인증 성공

해쉬함수 없는 공개키 기반의 메시지 인증
- 메시지를 작성 후 개인키로 메시지 전체를 암호화
- 공개키로 암호문 복호화
- 해독할 수 있는 평문을 얻으면 메세지 인증

- 메시지 전체에 대하여 메시지 인증코드의 생성 및 검증을 수행하므로 시간 많이 소요
- 별도의 해쉬 함수 필요 없음

해쉬함수 기반 메시지 인증
- 메시지 인증코드의 추가 전송으로 전송량 증가
- 메시지 인증코드의 생성 및 검증이 빠름


공유 비밀키 기반의 메시지 인증
1. 사전에 공유된 비밀키 있음
2. 송신자는 비밀키를 메시지에 추가하여 해쉬 함수 수행 : H(비밀키 + 메시지) = 메시지 다이제스트
3. 비밀키를 제외한 메시지와 생성된 메시지 다이제스트를 동시에 전송 : 메시지 + 메시지 다이제스트
4. 수신자는 메시지에 비밀키를 추가하여 해쉬함수 수행
5. 3번의 메시지 다이제스트와 4번의 결과 메시지 다이제스트가 동일하면 메시지 인증


HMAC
- 공유 비밀키 기반의 메시지 알고리즘
- 안전성 : 사용되는 해쉬 함수가 강한 충돌 회피성을 갖고 있는 경우 안전성 보장


공개키 방식 메시지 인증의 취약성
- 위조된 공개키 배포
- 위조된 개인키로 전자서명 생성하여 전송
- 위조된 공개키로 수신한 문서를 인증함

공개키 방식에서 인증서의 필요성
- 공개키의 위조를 방지하기 위하여 자신의 공개키 및 개인 정보를 인증기관에 인증서로 등록
- 공개키를 가져오기 위해 인증서를 인증 기관에 요청

공개키 기반 구조의 필요성
- 공개키를 관리하고 분배하는 구조 : PKI(public-key infra-structure)
- 공개키의 생성, 관리, 저장, 분배, 폐지등에 필요한 하드웨어, 소프트웨어, 인력, 정책 및 절차

구성요소
- 사용자 : 인증서를 발행받아 전자상거래나 인터넷 뱅킹 등을 사용
- 등록기관 : 인증서 신청자의 신원 확인 및 인증서 등록을 대행하는 기관
- 인증기관 : 인증서 발생하는 기관
- 저장소 : 인증서를 인증서의 취소목록을 저장하는 장소

인증서
- 공신력 있는 인증기관이 발행한 사이버 거래의 인감증명서
- 위조가 불가능하도록 실체의 정보와 공개키 
그리고 인증기과의 정보가 수록된 인증서를 인증기관의 개인키로 서명하여 발급
- ex) X.509, PGP

그 인증서가 진짜라는 것을 어떻게 증명??

인증기관
- 인증서의 생성, 배정, 관리 등의 작업을 수행하는 기관

- 민간분야 NPKI : KISA
- 정부분야 GPKI

키 생성 및 관리 - 사용자 키 생성 방식
1. 토큰 생성 : 사용자의 신분확인, 토크에는 사용자가 자신의 공개키/개인키 쌍을 생성할 수 있는 정보 포함
2. 토큰을 안전한 채널로 전송
3. 키 생성 : 공개키 개인키 생성
4. 인증서-생성 요청 : 공개키를 포함하고 있는 인증서-생성 요청 메시지 전송
5. 인증서-생성 응답 : 인증서-생성 요청 메시지의 유효성을 확인 후, 응답 메시지 사용자에게 전송
6. 인증서 저장 : 발급한 인증서를 인증서 보관소에 저장

키 생성 및 관리 : 중앙 집중형 키 생성 방식
1. 토큰 생성 : 사용자의 신원확인 후 토큰 생성, 토큰에는 인증기관이 생성한 사용자의 공개키/개인키 쌍과 인증서 포함
2. 토큰을 안전한 채널로 전송
3. 인증서 저장 : 발급한 인증서를 인증서 보관소에 저장
4. 사용자는 토큰에 있는 인증서와 공개키/개인키 사용

X.509 표준 권고안
- 이렉터리 서비스의 인증 지원
    - 인증서의 분배와 관련된 데이터 형식과 절차 정의
    - 인증서 폐지목록 메커니즘 정의

IETF 의 PKIX (public-key infrastructure X.509) 작업반
- X.509 기반의 PKI를 지원하기 위한 인터넷 표준 개발을 위하여 구성
- 프로파일 정의
- 운영 프로토콜
- 관리 프로토콜

X.509 인증서 형식

인증서의 상태 검사

인증서 폐지 목록(CRL)
- 일정한 시간 간격으로 CRL 발행
- 폐지된 인증서의 상태를 실시간으로 알 수 없음

온라인 인증서 상태확인 프로토콜(OCSP)
- 특정 인증서의 유효성을 온라인으로 언제든지 확인할 수 있는 매커니즘 제공

X.509 신뢰 모델
- 인증서의 유효성을 결정하기 위해 사용하는 규칙
- 계층적 신뢰를 사용
- 최상위 인증기관인 A는 자체 서명한 인증서ㅇ를 발행
- 최종 사용자 및 중간 인증기관의 인증서는 상위의 인증기관이 발급

인증서의 검증 절차
- 최상위 인증서가 아니면 인증서 발급자의 인증서를 구하여 검증 절차 재수행

최상위 인증기관
- 최상위 인증기관의 개인키는 엄격한 보안이 요구
    - 최소한 160비트 메시지 다이제스트를 갖는 해쉬함수 사용
    - 개인키의 길이는 최소한 2048 비트 사용

SSL/TLS 보안 프로토콜
- 보안 소켓 계층(SSL: secure socket layer)

- 트랜스포트 계층 보안(TLS: Transport layer security)

SSL/TLS 보안 서비스
- 기밀성
- 무결성
- 인증

SSL/TLS 보안 구조
- 핸드쉐이크 프로토콜
- 암호사양변경 프로토콜
- 경고 프로토콜
- 레코드 프로토콜

핸드쉐이크와 암호사양변경 프로토콜
- 3 핸드 쉐이크 직후 이루어지는 SSL 핸드 쉐이크
- 1-3 단계 : 핸드쉐이크 프로토콜
    - 1단계 : 보안 능력 설정
    - 2단계 : 서버 인증 및 키 교환
    - 3단계 : 클라이언트 인증 및 키 교환
- 4단계 : 암호사양 변경 메시지 교환 및 핸드쉐이크 종료
